  ___ ___ ___ ___ ______   _______ _______ ___ ___ _______ ______  
 |   Y   |   Y   |   _  \ |   _   |   _   |   Y   |   _   |   _  \ 
 |.  1   |   1   |.  |   \|   1___|.  1___|.  |   |.  1___|.  |   |
 |.  _   |\_   _/|.  |    |____   |.  __)_|.  |   |.  __)_|.  |   |
 |:  |   | |:  | |:  1    |:  1   |:  1   |:  1   |:  1   |:  |   |
 |::.|:. | |::.| |::.. . /|::.. . |::.. . |\:.. ./|::.. . |::.|   |
 `--- ---' `---' `------' `-------`-------' `---' `-------`--- ---'
Hydseven Windows 10 Firefox RCE/Sandbox Escape Exploit Chain [Stage 2]

~

Overview
                                 
This is a Windows variation of CVE-2019-11707, an exploit targetting a type
confusion bug in the Array.pop method during inlining/IonMonkey JIT compilation
of affected code in versions of Firefox up to 67.0.2. Notably, the sandbox
escape in this exploit will only work on Firefox 65.0.1 due to a dependence on
hardcoded xul.dll offsets.

Fundamentally this bug allows an attacker to trick IonMonkey into JIT'ing a
function popping and accessing an element of a specially crafted malicious
array without generating any speculative guards on the element type. In other
words, we can reliably produce an ASM routine for a JS function which is only
designed to handle array element access for a specific object type, while
allowing us to effectively modify the type of the element being accessed. Thus
a class object may be accessed as a float, a float as an integer, and so on.
The end result is a classic type confusion on the ASM layer which is leveraged
into an OOB array access, providing the basis for construction of R/W/AddressOf
primitives.

More specifically this bug allows for the creation of specially crafted
malicious  arrays with a specific element type set. By creating a function
which loops through this malicious array and calls Array.pop on its elements,
IonMonkey can be made to JIT an ASM routine specifically optimized to only
handle this one specific type of array element. The bug comes into affect in
the unique edge case of an object prototype: when Array.pop attempts to access
an element at an index which does not exist (such as in a sparse array) it will
then make a secondary, fall-back attempt to access this element index on the
prototype of its associated array. This would not be an issue if SpiderMonkey
tracked modifications to the type sets of prototype elements but it does not.

...

bool hasIndexedProperty;
MOZ_TRY_VAR(hasIndexedProperty, ArrayPrototypeHasIndexedProperty(this, script()));
if (hasIndexedProperty) {
    trackOptimizationOutcome(TrackedOutcome::ProtoIndexedProps);
    return InliningStatus_NotInlined;
    }

...

This was the vulnerable piece of code in SpiderMonkey which enabled the bug. It
can be plainly seen that they did attempt to check types of indexed elements
on array prototypes but did so incorrectly: every array will by default have a
special ArrayPrototype object associated with it. However, we do not need to
leave this default layout intact. We can set a custom prototype on our
malicious array (this custom prototype itself being an array) and trick the
engine into checking the ArrayPrototype of our custom prototype for indexed
elements instead of the custom prototype which contains the malicious untracked
elements. Practically speaking:

var SparseTrapdoorArray = [BugArrayUint32, BugArrayUint32];

This will produce:

SparseTrapdoorArray -> ArrayPrototype

Now if a new array is created and set as the custom prototype of
SparseTrapdoorArray:

var CustomPrototype = [new Uint8Array(BugArrayBuf)];
SparseTrapdoorArray.__proto__ = CustomPrototype;

This will produce:

SparseTrapdoorArray -> CustomPrototype -> ArrayPrototype

Thus an element access on a non-existent element of SparseTrapdoorArray will
access this same index on CustomPrototype instead, and it will be the
ArrayPrototype of CustomPrototype which is checked by SpiderMonkey during
inlining, not the actual prototype of the SparseTrapdoorArray array ie. the
CustomPrototype. If SparseTrapdoorArray[0] were to not exist and be accessed,
it would result in an access to the Uint8Array element at CustomPrototype[0]
despite the JIT'd function being optimized for access to Uint32Array at 
SparseTrapdoorArray[0].

~

Design

I created the exploit primitives for CVE-2019-11707 in much the same way as I
did CVE-2019-17026: the nursery heap is groomed so that 3 objects are lined up
in memory. In this case they are ArrayBuffers.

[Array 1][Array 2][Array 3]

We use the bug to overflow array 1 and corrupt the NativeObject of array 2,
artificially augmenting its length to encompass the NativeObject of array 3.
From this point onward, array 2 is used to corrupt the slots pointer within the
NativeObject of array 3 to do arbitrary reads, writes and addrof. 

Once these primitives are obtained, a JIT spray is used to plant an egg hunter
shellcode in +RX memory within the firefox.exe content process being hijacked.
The ASM source for my egg hunter can be found here:
https://github.com/forrest-orr/Exploits/blob/main/Payloads/Source/DoubleStar/Stage1_EggHunter/Egghunter64.asm

The role of this egg hunter is to search out a magic QWORD in memory prefixing
an arbitrary shellcode (in this case a WinExec shellcode) stored as a
Uint8Array somewhere in this content process, disable DEP on it, and execute
it via a branch instruction.

The JIT code pointer of the JIT sprayed function is identified by using the
arbitrary read/addrof primitives to walk its JitInfo struct, and then a
secondary egg hunter within the JS itself is used to scan this JIT'd region for
the JIT sprayed egg hunter shellcode itself, stored as a double float array and
implanted at the end of the JIT'd ASM. Once this array is found, the JIT code
pointer is modified to point to it, and the JIT sprayed function is run one 
last time, resulting in the WinExec shellcode being found in memory, set to
executable and executed.

~

Sandboxing

The lineage of the Firefox application involves a Medium Integrity AppContainer
firefox.exe "parent" process which is responsible for making network
connections and handling the UI, with a set of Low Integrity child/content
firefox.exe processes beneath it, each locked to a specific domain (in the past
it was one process per tab, now its one process per site) and responsible for
parsing and potentially compiling/executing Javascript.

The exploit within this source file compromises the parent process itself and
is thus not constrained by child/content process limitations on launching
processes or making UI operations. It is intended to be loaded via Prompt:Open
from the stage 1 of this exploit from the child process over IPC using
CVE-2019-11708.

~

Credits

0vercl0k  - for the original research/analysis of CVE-2019-11708 and reverse
            engineering of xul.dll for "god mode" patching.
			
sherl0ck  - for his writeup on CVE-2019-11707.